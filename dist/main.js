!function(n){var g={};function t(e){if(g[e])return g[e].exports;var I=g[e]={i:e,l:!1,exports:{}};return n[e].call(I.exports,I,I.exports,t),I.l=!0,I.exports}t.m=n,t.c=g,t.d=function(n,g,e){t.o(n,g)||Object.defineProperty(n,g,{configurable:!1,enumerable:!0,get:e})},t.r=function(n){Object.defineProperty(n,"__esModule",{value:!0})},t.n=function(n){var g=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(g,"a",g),g},t.o=function(n,g){return Object.prototype.hasOwnProperty.call(n,g)},t.p="",t(t.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./src/styles/index.css\nvar styles = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./src/input.js\n\n\nconst Input = (function() {\n  let keysDown = [];\n  let keysPressed = [];\n  let mouseEvent = undefined;\n\n  function keyDown(keyCode) {\n    if (keysPressed.indexOf(keyCode) < 0) {\n      keysPressed.push(keyCode);\n    }\n    if (keysDown.indexOf(keyCode) < 0) {\n      keysDown.push(keyCode);\n    }\n  }\n\n  function keyUp(keyCode) {\n    keysDown = keysDown.filter(element => {\n      return element != keyCode;\n    });\n  }\n\n  function getKeysPressed() {\n    return keysDown.concat(\n      keysPressed.filter(key => {\n        return keysDown.indexOf(key) < 0;\n      })\n    );\n  }\n\n  function mouseUp(event) {\n    mouseEvent = event;\n  }\n\n  function getMouseEvent() {\n    return mouseEvent;\n  }\n\n  function resetInputs() {\n    keysPressed = [];\n    mouseEvent = undefined;\n  }\n\n  return {\n    keyDown: keyDown,\n    keyUp: keyUp,\n    getKeysPressed: getKeysPressed,\n    mouseUp: mouseUp,\n    getMouseEvent: getMouseEvent,\n    resetInputs: resetInputs\n  };\n})();\n\n// CONCATENATED MODULE: ./src/asset_manager.js\n\n\nconst Assets = (function() {\n  let assets = {};\n\n  function loadAssets(assetOwners, callback) {\n    let tempAssetPaths = [];\n    for (let assetOwner of assetOwners) {\n      tempAssetPaths = tempAssetPaths.concat(assetOwner.assetPaths);\n    }\n    let assetPaths = [...new Set(tempAssetPaths)];\n\n    let assetsRemaining = assetPaths.length;\n    for (let assetPath of assetPaths) {\n      let asset = new Image();\n      asset.onload = function() {\n        assets[assetPath] = asset;\n        assetsRemaining--;\n        if (assetsRemaining <= 0) {\n          callback();\n        }\n      };\n      asset.src = assetPath;\n    }\n  }\n\n  function get(assetPath) {\n    return assets[assetPath];\n  }\n\n  return {\n    loadAssets: loadAssets,\n    get: get\n  };\n})();\n\n// CONCATENATED MODULE: ./src/asset_owner.js\n\n\n\nclass AssetOwner {\n\n  constructor(assetPaths) {\n    this.assetPaths = assetPaths;\n  }\n\n}\n\n// CONCATENATED MODULE: ./src/tile.js\n\n\n\n\n\nclass tile_Tile extends AssetOwner {\n  constructor(assetPaths) {\n    super(assetPaths);\n    this.tileWidth = 128;\n    this.tileHeight = 64;\n    this.imageFrameIndex = 0;\n  }\n\n  get img() {\n    return Assets.get(this.assetPaths[this.imageFrameIndex]);\n  }\n}\n\n// CONCATENATED MODULE: ./src/util.js\n\n\nconst rand = max => {\n  return Math.floor(Math.random() * Math.floor(max));\n};\n\nconst coordsEqual = (a, b) => {\n  if (a.x == undefined || b.x == undefined) {\n    console.log('Undefined value in util.coordsEqual');\n    console.log(`a.x: ${a.x} a.y: ${a.y} b.x: ${b.x} b.y: ${b.y}`);\n  }\n  // console.log('');\n  // console.log('in coordsEqual(a, b) =>');\n  // console.log(`a: ${a.constructor.name}`);\n  // console.log(`  x${a.x}, y${a.y}`);\n  // console.log(`a: ${b.constructor.name}`);\n  // console.log(`  x${b.x}, y${b.y}`);\n  // console.log('');\n  return a.x == b.x && a.y == b.y;\n};\n\nconst arrayIncludesCoords = (arr, coord_a) => {\n  return (\n    arr.filter(coord_b => {\n      return coordsEqual(coord_a, coord_b);\n    }).length > 0\n  );\n};\n\nconst entityMapLocationFromCell = (cell, map, frameOffsets) => {\n  // console.log('start entityMapLocationFromCell');\n  // console.log(cell);\n  let mapDestination = map.mapCoordsForCell({ x: cell.x, y: cell.y });\n  let tileOffset = map.tileOffsets;\n  let mapLocation = {\n    x: mapDestination.x + tileOffset.x - frameOffsets.x,\n    y: mapDestination.y + tileOffset.y - frameOffsets.y\n  };\n  // console.log(mapLocation);\n  return mapLocation;\n};\n\nconst Facing = {\n  SOUTHEAST: 7,\n  SOUTHWEST: 1,\n  NORTHWEST: 3,\n  NORTHEAST: 5\n};\n\n// CONCATENATED MODULE: ./src/cell.js\n\n\nclass Cell {\n  constructor(tile, map, coords) {\n    this.tile = tile;\n    this.map = map;\n    this.coords = coords;\n  }\n\n  get neighbors() {\n    return this.map.neighbors(this.coords);\n  }\n\n  get x() {\n    return this.coords.x;\n  }\n\n  get y() {\n    return this.coords.y;\n  }\n}\n\n// CONCATENATED MODULE: ./src/map.js\n\n\n\n\n\nclass Map {\n  constructor(tiles, mapSize) {\n    this.tiles = tiles;\n    this.mapSize = mapSize;\n    this.tileWidth = tiles[0].tileWidth;\n    this.tileHeight = tiles[0].tileHeight;\n    this.cells = buildCells(this);\n  }\n\n  get mapCanvas() {\n    if (this.myMapCanvas == undefined) {\n      this.myMapCanvas = drawMapCanvas(this);\n    }\n    return this.myMapCanvas;\n  }\n\n  mapCoordsForCell(cellCoords) {\n    let xOffset = (this.mapSize * this.tileWidth) / 2 - this.tileWidth / 2;\n    let mapX = (cellCoords.x - cellCoords.y) * (this.tileWidth / 2) + xOffset;\n    let mapY = (cellCoords.x + cellCoords.y) * (this.tileHeight / 2);\n    return { x: mapX, y: mapY };\n  }\n\n  get tileOffsets() {\n    return { x: this.tileWidth / 2, y: this.tileHeight / 2 };\n  }\n\n  cellAt(coords) {\n    return this.cells[coords.x][coords.y];\n  }\n\n  neighbors(coords) {\n    let neighbors = [];\n    if (coords.x < this.mapSize - 1) {\n      neighbors.push(this.cells[coords.x + 1][coords.y]);\n    }\n    if (coords.x > 0) {\n      neighbors.push(this.cells[coords.x - 1][coords.y]);\n    }\n    if (coords.y < this.mapSize - 1) {\n      neighbors.push(this.cells[coords.x][coords.y + 1]);\n    }\n    if (coords.y > 0) {\n      neighbors.push(this.cells[coords.x][coords.y - 1]);\n    }\n    return neighbors;\n  }\n}\n\nfunction buildCells(map) {\n  let cells = [];\n  for (let i = 0; i < map.mapSize; i++) {\n    cells[i] = [];\n    for (let j = 0; j < map.mapSize; j++) {\n      cells[i][j] = new Cell(map.tiles[rand(map.tiles.length)], map, {\n        x: i,\n        y: j\n      });\n    }\n  }\n  return cells;\n}\n\nfunction drawMapCanvas(map) {\n  let mapCanvas = document.createElement('canvas');\n  mapCanvas.width = map.mapSize * map.tileWidth - map.mapSize;\n  mapCanvas.height = map.mapSize * map.tileHeight - map.mapSize;\n\n  for (let [x, row] of map.cells.entries()) {\n    for (let [y, cell] of row.entries()) {\n      drawTile(map, mapCanvas.getContext('2d'), cell.tile, x, y);\n    }\n  }\n  return mapCanvas;\n}\n\nfunction drawTile(map, context, tile, mapX, mapY) {\n  let contextCoords = map.mapCoordsForCell({ x: mapX, y: mapY });\n  context.drawImage(\n    tile.img,\n    contextCoords.x,\n    contextCoords.y,\n    map.tileWidth,\n    map.tileHeight\n  );\n}\n\n// CONCATENATED MODULE: ./src/entity.js\n\n\n\n\n\n\nclass entity_Entity extends AssetOwner {\n  constructor(entityDef, map, brain) {\n    super(entityDef.imagePaths);\n    this.frameSize = entityDef.frameSize;\n    this.frameOffsets = entityDef.frameOffsets || { x: 0, y: 0 };\n    this.map = map;\n    this.currentCell = this.map.cellAt(entityDef.startCell || { x: 0, y: 0 });\n    this.myLocation = entityMapLocationFromCell(\n      this.currentCell,\n      this.map,\n      this.frameOffsets\n    );\n    this.cellPath = [];\n    this.brain = brain;\n    this.destination = undefined;\n    this.facing = entityDef.facing;\n  }\n\n  get image() {\n    return Assets.get(this.assetPaths[0]);\n  }\n\n  get location() {\n    // console.log(this.myLocation);\n    return this.myLocation;\n  }\n\n  set location(newLocation) {\n    let newFacing = undefined;\n    if (newLocation != undefined && this.myLocation != undefined) {\n      if (\n        newLocation.x >= this.myLocation.x &&\n        newLocation.y >= this.myLocation.y\n      ) {\n        newFacing = Facing.SOUTHEAST;\n      } else if (\n        newLocation.x >= this.myLocation.x &&\n        newLocation.y <= this.myLocation.y\n      ) {\n        newFacing = Facing.NORTHEAST;\n      } else if (\n        newLocation.x <= this.myLocation.x &&\n        newLocation.y <= this.myLocation.y\n      ) {\n        newFacing = Facing.NORTHWEST;\n      } else if (\n        newLocation.x <= this.myLocation.x &&\n        newLocation.y >= this.myLocation.y\n      ) {\n        newFacing = Facing.SOUTHWEST;\n      } else {\n        newFacing = Facing.NORTHEAST;\n      }\n    }\n    this.facing = newFacing;\n    this.myLocation = newLocation;\n  }\n\n  get frameXOrigin() {\n    if (this.facing != undefined) {\n      return this.facing * this.frameSize.width;\n    }\n    return 0;\n  }\n\n  get frameYOrigin() {\n    return 0;\n  }\n\n  respondToMouse(eventCell, blockingAnimationCallback) {\n    if (this.activity == undefined) {\n      this.activity = this.brain.getActivity(\n        this,\n        eventCell,\n        blockingAnimationCallback\n      );\n    }\n  }\n\n  activityDone() {\n    this.activity = undefined;\n  }\n\n  tick() {\n    if (this.activity != undefined) {\n      this.activity();\n    }\n  }\n}\n\n// CONCATENATED MODULE: ./src/binary_heap.js\n// Code for binary heap adapted from\n// http://eloquentjavascript.net/1st_edition/appendix2.html\n// by Marijn Haverbeke\n\n\n\nclass BinaryHeap {\n  constructor(scoreFunction, equalityFunction) {\n    this.scoreFunction = scoreFunction;\n    this.equalityFunction = equalityFunction;\n    this.elements = [];\n  }\n\n  first() {\n    return this.elements[0];\n  }\n\n  push(newElement) {\n    // Add the new element to the end of the array.\n    this.elements.push(newElement);\n    // Allow it to bubble up.\n    this.bubbleUp(this.elements.length - 1);\n  }\n\n  pop() {\n    // Store the first element so we can return it later.\n    let first = this.elements[0];\n    // Get the element at the end of the array.\n    let last = this.elements.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it sink down.\n    if (this.elements.length > 0) {\n      this.elements[0] = last;\n      this.sinkDown(0);\n    }\n    return first;\n  }\n\n  remove(targetElement) {\n    for (let [i, element] of this.elements.entries()) {\n      if (this.equalityFunction(targetElement, element)) {\n        let lastElement = this.elements.pop();\n        if (!(i == length - 1)) {\n          this.elements[i] = lastElement;\n          this.bubbleUp(i);\n          this.sinkDown(i);\n        }\n      }\n    }\n  }\n\n  size() {\n    return this.elements.length;\n  }\n\n  includes(targetElement) {\n    return this.elements.indexOf(targetElement) != -1;\n  }\n\n  bubbleUp(i) {\n    // Fetch the element that has to be moved.\n    let element = this.elements[i],\n      score = this.scoreFunction(element);\n    // When at 0, an element cannot go up any further.\n    while (i > 0) {\n      // Compute the parent element's index, and fetch it.\n      let parentI = Math.floor((i + 1) / 2) - 1,\n        parent = this.elements[parentI];\n      // If the parent has a lesser score, things are in order and we\n      // are done.\n      if (score >= this.scoreFunction(parent)) break;\n      // Otherwise, swap the parent with the current element and\n      // continue.\n      this.elements[parentI] = element;\n      this.elements[i] = parent;\n      i = parentI;\n    }\n  }\n\n  sinkDown(i) {\n    // Look up the target element and its score.\n    var length = this.elements.length,\n      element = this.elements[i],\n      score = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2i = (i + 1) * 2,\n        child1i = child2i - 1;\n      // This is used to store the new position of the element,\n      // if any.\n      var swap = null;\n      // If the first child exists (is inside the array)...\n      if (child1i < length) {\n        // Look it up and compute its score.\n        var child1 = this.elements[child1i],\n          child1Score = this.scoreFunction(child1);\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < score) swap = child1i;\n      }\n      // Do the same checks for the other child.\n      if (child2i < length) {\n        var child2 = this.elements[child2i],\n          child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap == null ? score : child1Score)) swap = child2i;\n      }\n\n      // No need to swap further, we are done.\n      if (swap == null) break;\n\n      // Otherwise, swap and continue.\n      this.elements[i] = this.elements[swap];\n      this.elements[swap] = element;\n      i = swap;\n    }\n  }\n}\n\n// CONCATENATED MODULE: ./src/brain.js\n\n\n\n\n\nclass brain_MobileBrain {\n  getActivity(entity, eventCell, blockingAnimationCallback) {\n    let startCell = entity.currentCell;\n    let endCell = eventCell;\n    let cellPath = buildCellPathAStar(startCell, endCell);\n    let destination = undefined;\n    blockingAnimationCallback(true);\n    return () => {\n      if (destination != undefined) {\n        let nextPosition = getNextMapPosition(entity, destination);\n        entity.location = nextPosition;\n        if (coordsEqual(entity.location, destination)) {\n          destination = undefined;\n        }\n      } else if (cellPath.length > 0) {\n        entity.currentCell = cellPath[0];\n        destination = getDestination(entity, cellPath);\n      } else {\n        entity.activityDone();\n        blockingAnimationCallback(false);\n      }\n    };\n  }\n}\n\nfunction getNextMapPosition(entity, destination) {\n  let currentLoc = { x: entity.location.x, y: entity.location.y };\n  let dx = currentLoc.x - destination.x,\n    dy = currentLoc.y - destination.y;\n  let dist = Math.sqrt(dx * dx + dy * dy);\n  let velX = (dx / dist) * 5;\n  let velY = (dy / dist) * 5;\n  if (Math.abs(dx) < Math.abs(velX)) {\n    velX = dx;\n  }\n  if (Math.abs(dy) < Math.abs(velY)) {\n    velY = dy;\n  }\n  return {\n    x: (currentLoc.x -= velX),\n    y: (currentLoc.y -= velY)\n  };\n}\n\nfunction getDestination(entity, cellPath) {\n  let nextCellDestination = cellPath.shift();\n  let nextDestination = undefined;\n  if (nextCellDestination != undefined) {\n    nextDestination = entityMapLocationFromCell(\n      nextCellDestination,\n      entity.map,\n      entity.frameOffsets\n    );\n  }\n  return nextDestination;\n}\n\n// Uses Brensenham's line algorithm\nfunction buildCellPath(start, end) {\n  let path = [];\n\n  let currentX = start.x,\n    currentY = start.y;\n  let deltaX = Math.abs(end.x - start.x),\n    deltaY = Math.abs(end.y - start.y);\n  let slopeX = start.x < end.x ? 1 : -1,\n    slopeY = start.y < end.y ? 1 : -1;\n  let err = deltaX - deltaY;\n\n  while (currentX != end.x || currentY != end.y) {\n    let err2 = 2 * err;\n    if (err2 > deltaY * -1) {\n      err -= deltaY;\n      currentX += slopeX;\n    } else if (err2 < deltaX) {\n      err += deltaX;\n      currentY += slopeY;\n    }\n    path.push({ x: currentX, y: currentY });\n  }\n  return path;\n}\n\nfunction buildCellPathAStar(start, end) {\n  // console.log('start buildCellPathAStar');\n  let open = new BinaryHeap(\n    a => {\n      return a.f;\n    },\n    (a, b) => {\n      return coordsEqual(a, b);\n    }\n  );\n  open.push(new GraphNode(start));\n  let closed = [];\n  // console.log(`end: ${end.constructor.name}`);\n  // console.log(`  x${end.x}, y${end.y}`);\n  while (open.size() > 0) {\n    let currentNode = open.pop();\n    closed.push(currentNode);\n    // console.log('');\n    // console.log('Considering....');\n    // console.log(currentNode.constructor.name);\n    // console.log(`  x${currentNode.x}, y${currentNode.y}, f${currentNode.f}`);\n    if (coordsEqual(currentNode, end)) {\n      // console.log(\n      //   `currentNode x${currentNode.x}, y${currentNode.y} is end node x${\n      //     end.x\n      //   }, y${end.y}`\n      // );\n      return buildPath(currentNode);\n    }\n    // console.log(`closed:`);\n    // for (let closedNode of closed) {\n    // console.log(\n    //   `  ${closedNode.constructor.name}: x${closedNode.x}, y${closedNode.y}`\n    // );\n    // }\n    let neighbors = currentNode.neighbors;\n    for (let neighbor of neighbors) {\n      // console.log(\n      //   `Considering neighbor ${neighbor.constructor.name} x${neighbor.x}, y${\n      //     neighbor.y\n      //   }`\n      // );\n      if (!arrayIncludesCoords(closed, neighbor)) {\n        let g = currentNode.g + 1;\n        // console.log(`  neighbor has g${neighbor.g}, f${neighbor.f}`);\n        // console.log(\n        //   `  closed does not include neighbor x${neighbor.x}, y${neighbor.y}`\n        // );\n        if (!open.includes(neighbor)) {\n          open.push(neighbor);\n        } else if (g >= neighbor.g) {\n          continue;\n        }\n        neighbor.parent = currentNode;\n        neighbor.f = neighbor.g + manhattenDistance(neighbor, end);\n        console.log(neighbor.f);\n      }\n    }\n  }\n}\n\nfunction buildPath(endNode) {\n  let path = [];\n  while (endNode.parent) {\n    path.push(endNode.cell);\n    endNode = endNode.parent;\n  }\n  return path.reverse();\n}\n\nfunction manhattenDistance(start, end) {\n  return Math.abs(start.x - end.x) + Math.abs(start.y - end.y);\n}\n\nclass GraphNode {\n  constructor(cell) {\n    this.cell = cell;\n    this.f = 0;\n  }\n  get neighbors() {\n    if (this.myNeighbors == undefined) {\n      return this.cell.neighbors.map(neighbor => {\n        return new GraphNode(neighbor);\n      });\n    }\n    return this.myNeighbors;\n  }\n  set g(newG) {\n    /* no op, g is computed from parent.g */\n  }\n  get g() {\n    return this.parent != undefined ? this.parent.g + 1 : 0;\n  }\n  get coords() {\n    return this.cell.coords;\n  }\n  get x() {\n    return this.cell.coords.x;\n  }\n  get y() {\n    return this.cell.coords.y;\n  }\n}\n\n// CONCATENATED MODULE: ./src/scene.js\n\n\n\n\n\n\n\n\n\nclass scene_Scene {\n  constructor(sceneDef, viewport, viewportDimensions, loadCompleteCallback) {\n    let tiles = sceneDef.mapDef.tileImagePaths.map(tileImagePath => {\n      return new tile_Tile([tileImagePath]);\n    });\n\n    this.map = new Map(tiles, sceneDef.mapDef.mapSize);\n\n    this.mobiles = sceneDef.mobileDefs.map(mobileDef => {\n      return new entity_Entity(mobileDef, this.map, new brain_MobileBrain());\n    });\n    this.activeMobile = this.mobiles[0];\n    this.props = sceneDef.propDefs.map(propDef => {\n      return new entity_Entity(propDef, this.map);\n    });\n\n    this.viewport = viewport;\n    this.viewportDimensions = viewportDimensions;\n\n    Assets.loadAssets([...tiles, ...this.mobiles, ...this.props], () => {\n      this.viewportOffsetDimensions = {\n        x: this.map.mapCanvas.width / 2 - viewportDimensions.x / 2,\n        y: this.map.mapCanvas.height / 2 - viewportDimensions.y / 2\n      };\n      loadCompleteCallback();\n    });\n\n    this.waitingOnAnimation = false;\n  }\n\n  tick() {\n    let mouseEvent = Input.getMouseEvent();\n    if (mouseEvent != undefined) {\n      let eventViewportPosition = getEventViewportPosition(\n        this.viewport,\n        mouseEvent\n      );\n      let eventMapPosition = getCursorMapPosition(\n        this.viewportOffsetDimensions,\n        eventViewportPosition\n      );\n      let cellPosition = getCursorCellPosition(this.map, eventMapPosition);\n\n      if (!this.waitingOnAnimation) {\n        this.activeMobile.respondToMouse(\n          this.map.cellAt(cellPosition),\n          shouldWait => {\n            this.waitingOnAnimation = shouldWait;\n          }\n        );\n\n        if (this.mobiles.slice(-1)[0] == this.activeMobile) {\n          this.activeMobile = this.mobiles[0];\n        } else {\n          this.activeMobile = this.mobiles[\n            this.mobiles.indexOf(this.activeMobile) + 1\n          ];\n        }\n      }\n    }\n\n    this.mobiles.forEach(mobile => {\n      mobile.tick();\n    });\n    this.props.forEach(prop => {\n      prop.tick();\n    });\n\n    let context = this.viewport.getContext('2d');\n    context.clearRect(\n      0,\n      0,\n      this.viewportDimensions.x,\n      this.viewportDimensions.y\n    );\n    context.drawImage(\n      this.map.mapCanvas,\n      this.viewportOffsetDimensions.x,\n      this.viewportOffsetDimensions.y,\n      this.viewportDimensions.x,\n      this.viewportDimensions.y,\n      0,\n      0,\n      this.viewportDimensions.x,\n      this.viewportDimensions.y\n    );\n\n    this.mobiles.forEach(mobile => {\n      context.drawImage(\n        mobile.image,\n        mobile.frameXOrigin,\n        mobile.frameYOrigin,\n        mobile.frameSize.width,\n        mobile.frameSize.height,\n        mobile.location.x - this.viewportOffsetDimensions.x,\n        mobile.location.y - this.viewportOffsetDimensions.y,\n        mobile.frameSize.width,\n        mobile.frameSize.height\n      );\n    });\n\n    this.props.forEach(prop => {\n      context.drawImage(\n        prop.image,\n        prop.frameXOrigin,\n        prop.frameYOrigin,\n        prop.frameSize.width,\n        prop.frameSize.height,\n        prop.location.x - this.viewportOffsetDimensions.x,\n        prop.location.y - this.viewportOffsetDimensions.y,\n        prop.frameSize.width,\n        prop.frameSize.height\n      );\n    });\n\n    Input.resetInputs();\n  }\n}\n\nfunction getCursorMapPosition(viewOffsets, position) {\n  return { x: viewOffsets.x + position.x, y: viewOffsets.y + position.y };\n}\n\nfunction getCursorCellPosition(map, position) {\n  let halfTileWidth = map.tileWidth / 2;\n  let halfTileHeight = map.tileHeight / 2;\n  let halfMapSize = map.mapSize / 2;\n  let cellX =\n    (position.x / halfTileWidth + position.y / halfTileHeight) / 2 -\n    halfMapSize;\n  let cellY =\n    (position.y / halfTileHeight - position.x / halfTileWidth) / 2 +\n    halfMapSize;\n  return { x: Math.floor(cellX), y: Math.floor(cellY) };\n}\n\nfunction getEventViewportPosition(viewport, event) {\n  let rect = viewport.getBoundingClientRect();\n  let x = event.clientX - rect.left;\n  let y = event.clientY - rect.top;\n  return { x: x, y: y };\n}\n\n// CONCATENATED MODULE: ./src/scene_definition.js\n\n\nconst scene_definition_sceneDef = {\n  mapDef: {\n    mapSize: 10,\n    tileImagePaths: [\n      './src/img/ground_tiles/brickpavers2.png',\n      './src/img/ground_tiles/concrete368a.png',\n      './src/img/ground_tiles/cretebrick970.png',\n      './src/img/ground_tiles/dirt.png',\n      './src/img/ground_tiles/dirtsand2.png',\n      './src/img/ground_tiles/rock.png',\n      './src/img/ground_tiles/snow.png',\n      './src/img/ground_tiles/stone.png'\n    ]\n  },\n  mobileDefs: [\n    {\n      imagePaths: ['./src/img/mobiles/8way_mobile.png'],\n      startCell: { x: 3, y: 3 },\n      frameSize: { width: 60, height: 110 },\n      frameOffsets: { x: 30, y: 110 }\n    },\n    {\n      imagePaths: ['./src/img/mobiles/8way_mobile.png'],\n      startCell: { x: 5, y: 4 },\n      frameSize: { width: 60, height: 110 },\n      frameOffsets: { x: 30, y: 110 }\n    },\n    {\n      imagePaths: ['./src/img/mobiles/8way_mobile.png'],\n      startCell: { x: 3, y: 6 },\n      frameSize: { width: 60, height: 110 },\n      frameOffsets: { x: 30, y: 110 }\n    }\n  ],\n  propDefs: [\n    {\n      imagePaths: ['./src/img/props/statue1-01.png'],\n      startCell: { x: 5, y: 5 },\n      frameSize: { width: 128, height: 128 },\n      frameOffsets: { x: 0, y: 14 }\n    },\n    {\n      imagePaths: ['./src/img/props/statue1-02.png'],\n      startCell: { x: 0, y: 3 },\n      frameSize: { width: 128, height: 128 },\n      frameOffsets: { x: 0, y: 14 }\n    },\n    {\n      imagePaths: ['./src/img/props/statue1-03.png'],\n      startCell: { x: 4, y: 1 },\n      frameSize: { width: 128, height: 128 },\n      frameOffsets: { x: 0, y: 14 }\n    },\n    {\n      imagePaths: ['./src/img/props/statue1-04.png'],\n      startCell: { x: 5, y: 1 },\n      frameSize: { width: 128, height: 128 },\n      frameOffsets: { x: 0, y: 14 }\n    },\n    {\n      imagePaths: ['./src/img/props/statue1-02.png'],\n      startCell: { x: 6, y: 0 },\n      frameSize: { width: 128, height: 128 },\n      frameOffsets: { x: 0, y: 14 }\n    },\n    {\n      imagePaths: ['./src/img/props/statue1-03.png'],\n      startCell: { x: 7, y: 9 },\n      frameSize: { width: 128, height: 128 },\n      frameOffsets: { x: 0, y: 14 }\n    }\n  ]\n};\n\n// CONCATENATED MODULE: ./src/index.js\n\n\n\n\n\n\n\n\n\ndocument.addEventListener('DOMContentLoaded', function() {\n  console.log('Proxma Reverie approaches!');\n\n  // console.log('testing BinaryHeap');\n  // let heap = new BinaryHeap(\n  //   el => {\n  //     return el;\n  //   },\n  //   (a, b) => {\n  //     return a == b;\n  //   }\n  // );\n  // for (let entry of [10, 3, 4, 8, 2, 9, 7, 1, 2, 6, 5]) {\n  //   heap.push(entry);\n  // }\n  // heap.remove(2);\n  // while (heap.size() > 0) {\n  //   console.log(heap.pop());\n  // }\n\n  let tickLength = 20;\n\n  var viewport = document.getElementById('viewport-canvas');\n  let viewportDimensions = { x: 600, y: 400 };\n  viewport.width = viewportDimensions.x;\n  viewport.height = viewportDimensions.y;\n\n  let scene = new scene_Scene(scene_definition_sceneDef, viewport, viewportDimensions, () => {\n    setTimeout(() => {\n      tick();\n    }, 0);\n  });\n\n  function tick() {\n    scene.tick();\n    setTimeout(() => {\n      tick();\n    }, tickLength);\n  }\n\n  document.addEventListener('keydown', event => {\n    Input.keyDown(event.key);\n  });\n\n  document.addEventListener('keyup', event => {\n    Input.keyUp(event.key);\n  });\n\n  viewport.addEventListener('mouseup', event => {\n    Input.mouseUp(event);\n  });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9pbnB1dC5qcz85ZWY4Iiwid2VicGFjazovLy8uL3NyYy9hc3NldF9tYW5hZ2VyLmpzP2FlMGMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0X293bmVyLmpzPzc0YTIiLCJ3ZWJwYWNrOi8vLy4vc3JjL3RpbGUuanM/MGM4MCIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC5qcz9lMGViIiwid2VicGFjazovLy8uL3NyYy9jZWxsLmpzPzI0MDQiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hcC5qcz8xOGJhIiwid2VicGFjazovLy8uL3NyYy9lbnRpdHkuanM/NjI3YSIsIndlYnBhY2s6Ly8vLi9zcmMvYmluYXJ5X2hlYXAuanM/YmQyMSIsIndlYnBhY2s6Ly8vLi9zcmMvYnJhaW4uanM/M2JjMyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NlbmUuanM/MjY0YyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NlbmVfZGVmaW5pdGlvbi5qcz80YjhmIiwid2VicGFjazovLy8uL3NyYy9pbmRleC5qcz9iNjM1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGNvbnN0IElucHV0ID0gKGZ1bmN0aW9uKCkge1xuICBsZXQga2V5c0Rvd24gPSBbXTtcbiAgbGV0IGtleXNQcmVzc2VkID0gW107XG4gIGxldCBtb3VzZUV2ZW50ID0gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIGtleURvd24oa2V5Q29kZSkge1xuICAgIGlmIChrZXlzUHJlc3NlZC5pbmRleE9mKGtleUNvZGUpIDwgMCkge1xuICAgICAga2V5c1ByZXNzZWQucHVzaChrZXlDb2RlKTtcbiAgICB9XG4gICAgaWYgKGtleXNEb3duLmluZGV4T2Yoa2V5Q29kZSkgPCAwKSB7XG4gICAgICBrZXlzRG93bi5wdXNoKGtleUNvZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGtleVVwKGtleUNvZGUpIHtcbiAgICBrZXlzRG93biA9IGtleXNEb3duLmZpbHRlcihlbGVtZW50ID0+IHtcbiAgICAgIHJldHVybiBlbGVtZW50ICE9IGtleUNvZGU7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRLZXlzUHJlc3NlZCgpIHtcbiAgICByZXR1cm4ga2V5c0Rvd24uY29uY2F0KFxuICAgICAga2V5c1ByZXNzZWQuZmlsdGVyKGtleSA9PiB7XG4gICAgICAgIHJldHVybiBrZXlzRG93bi5pbmRleE9mKGtleSkgPCAwO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91c2VVcChldmVudCkge1xuICAgIG1vdXNlRXZlbnQgPSBldmVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1vdXNlRXZlbnQoKSB7XG4gICAgcmV0dXJuIG1vdXNlRXZlbnQ7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldElucHV0cygpIHtcbiAgICBrZXlzUHJlc3NlZCA9IFtdO1xuICAgIG1vdXNlRXZlbnQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGtleURvd246IGtleURvd24sXG4gICAga2V5VXA6IGtleVVwLFxuICAgIGdldEtleXNQcmVzc2VkOiBnZXRLZXlzUHJlc3NlZCxcbiAgICBtb3VzZVVwOiBtb3VzZVVwLFxuICAgIGdldE1vdXNlRXZlbnQ6IGdldE1vdXNlRXZlbnQsXG4gICAgcmVzZXRJbnB1dHM6IHJlc2V0SW5wdXRzXG4gIH07XG59KSgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgY29uc3QgQXNzZXRzID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgYXNzZXRzID0ge307XG5cbiAgZnVuY3Rpb24gbG9hZEFzc2V0cyhhc3NldE93bmVycywgY2FsbGJhY2spIHtcbiAgICBsZXQgdGVtcEFzc2V0UGF0aHMgPSBbXTtcbiAgICBmb3IgKGxldCBhc3NldE93bmVyIG9mIGFzc2V0T3duZXJzKSB7XG4gICAgICB0ZW1wQXNzZXRQYXRocyA9IHRlbXBBc3NldFBhdGhzLmNvbmNhdChhc3NldE93bmVyLmFzc2V0UGF0aHMpO1xuICAgIH1cbiAgICBsZXQgYXNzZXRQYXRocyA9IFsuLi5uZXcgU2V0KHRlbXBBc3NldFBhdGhzKV07XG5cbiAgICBsZXQgYXNzZXRzUmVtYWluaW5nID0gYXNzZXRQYXRocy5sZW5ndGg7XG4gICAgZm9yIChsZXQgYXNzZXRQYXRoIG9mIGFzc2V0UGF0aHMpIHtcbiAgICAgIGxldCBhc3NldCA9IG5ldyBJbWFnZSgpO1xuICAgICAgYXNzZXQub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGFzc2V0c1thc3NldFBhdGhdID0gYXNzZXQ7XG4gICAgICAgIGFzc2V0c1JlbWFpbmluZy0tO1xuICAgICAgICBpZiAoYXNzZXRzUmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgYXNzZXQuc3JjID0gYXNzZXRQYXRoO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldChhc3NldFBhdGgpIHtcbiAgICByZXR1cm4gYXNzZXRzW2Fzc2V0UGF0aF07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxvYWRBc3NldHM6IGxvYWRBc3NldHMsXG4gICAgZ2V0OiBnZXRcbiAgfTtcbn0pKCk7XG4iLCJcblwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBc3NldE93bmVyIHtcblxuICBjb25zdHJ1Y3Rvcihhc3NldFBhdGhzKSB7XG4gICAgdGhpcy5hc3NldFBhdGhzID0gYXNzZXRQYXRocztcbiAgfVxuXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IEFzc2V0cyB9IGZyb20gJy4vYXNzZXRfbWFuYWdlcic7XG5pbXBvcnQgQXNzZXRPd25lciBmcm9tICcuL2Fzc2V0X293bmVyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGlsZSBleHRlbmRzIEFzc2V0T3duZXIge1xuICBjb25zdHJ1Y3Rvcihhc3NldFBhdGhzKSB7XG4gICAgc3VwZXIoYXNzZXRQYXRocyk7XG4gICAgdGhpcy50aWxlV2lkdGggPSAxMjg7XG4gICAgdGhpcy50aWxlSGVpZ2h0ID0gNjQ7XG4gICAgdGhpcy5pbWFnZUZyYW1lSW5kZXggPSAwO1xuICB9XG5cbiAgZ2V0IGltZygpIHtcbiAgICByZXR1cm4gQXNzZXRzLmdldCh0aGlzLmFzc2V0UGF0aHNbdGhpcy5pbWFnZUZyYW1lSW5kZXhdKTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgY29uc3QgcmFuZCA9IG1heCA9PiB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBNYXRoLmZsb29yKG1heCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvb3Jkc0VxdWFsID0gKGEsIGIpID0+IHtcbiAgaWYgKGEueCA9PSB1bmRlZmluZWQgfHwgYi54ID09IHVuZGVmaW5lZCkge1xuICAgIGNvbnNvbGUubG9nKCdVbmRlZmluZWQgdmFsdWUgaW4gdXRpbC5jb29yZHNFcXVhbCcpO1xuICAgIGNvbnNvbGUubG9nKGBhLng6ICR7YS54fSBhLnk6ICR7YS55fSBiLng6ICR7Yi54fSBiLnk6ICR7Yi55fWApO1xuICB9XG4gIC8vIGNvbnNvbGUubG9nKCcnKTtcbiAgLy8gY29uc29sZS5sb2coJ2luIGNvb3Jkc0VxdWFsKGEsIGIpID0+Jyk7XG4gIC8vIGNvbnNvbGUubG9nKGBhOiAke2EuY29uc3RydWN0b3IubmFtZX1gKTtcbiAgLy8gY29uc29sZS5sb2coYCAgeCR7YS54fSwgeSR7YS55fWApO1xuICAvLyBjb25zb2xlLmxvZyhgYTogJHtiLmNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gIC8vIGNvbnNvbGUubG9nKGAgIHgke2IueH0sIHkke2IueX1gKTtcbiAgLy8gY29uc29sZS5sb2coJycpO1xuICByZXR1cm4gYS54ID09IGIueCAmJiBhLnkgPT0gYi55O1xufTtcblxuZXhwb3J0IGNvbnN0IGFycmF5SW5jbHVkZXNDb29yZHMgPSAoYXJyLCBjb29yZF9hKSA9PiB7XG4gIHJldHVybiAoXG4gICAgYXJyLmZpbHRlcihjb29yZF9iID0+IHtcbiAgICAgIHJldHVybiBjb29yZHNFcXVhbChjb29yZF9hLCBjb29yZF9iKTtcbiAgICB9KS5sZW5ndGggPiAwXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgZW50aXR5TWFwTG9jYXRpb25Gcm9tQ2VsbCA9IChjZWxsLCBtYXAsIGZyYW1lT2Zmc2V0cykgPT4ge1xuICAvLyBjb25zb2xlLmxvZygnc3RhcnQgZW50aXR5TWFwTG9jYXRpb25Gcm9tQ2VsbCcpO1xuICAvLyBjb25zb2xlLmxvZyhjZWxsKTtcbiAgbGV0IG1hcERlc3RpbmF0aW9uID0gbWFwLm1hcENvb3Jkc0ZvckNlbGwoeyB4OiBjZWxsLngsIHk6IGNlbGwueSB9KTtcbiAgbGV0IHRpbGVPZmZzZXQgPSBtYXAudGlsZU9mZnNldHM7XG4gIGxldCBtYXBMb2NhdGlvbiA9IHtcbiAgICB4OiBtYXBEZXN0aW5hdGlvbi54ICsgdGlsZU9mZnNldC54IC0gZnJhbWVPZmZzZXRzLngsXG4gICAgeTogbWFwRGVzdGluYXRpb24ueSArIHRpbGVPZmZzZXQueSAtIGZyYW1lT2Zmc2V0cy55XG4gIH07XG4gIC8vIGNvbnNvbGUubG9nKG1hcExvY2F0aW9uKTtcbiAgcmV0dXJuIG1hcExvY2F0aW9uO1xufTtcblxuZXhwb3J0IGNvbnN0IEZhY2luZyA9IHtcbiAgU09VVEhFQVNUOiA3LFxuICBTT1VUSFdFU1Q6IDEsXG4gIE5PUlRIV0VTVDogMyxcbiAgTk9SVEhFQVNUOiA1XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDZWxsIHtcbiAgY29uc3RydWN0b3IodGlsZSwgbWFwLCBjb29yZHMpIHtcbiAgICB0aGlzLnRpbGUgPSB0aWxlO1xuICAgIHRoaXMubWFwID0gbWFwO1xuICAgIHRoaXMuY29vcmRzID0gY29vcmRzO1xuICB9XG5cbiAgZ2V0IG5laWdoYm9ycygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAubmVpZ2hib3JzKHRoaXMuY29vcmRzKTtcbiAgfVxuXG4gIGdldCB4KCkge1xuICAgIHJldHVybiB0aGlzLmNvb3Jkcy54O1xuICB9XG5cbiAgZ2V0IHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29vcmRzLnk7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgcmFuZCB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgQ2VsbCBmcm9tICcuL2NlbGwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXAge1xuICBjb25zdHJ1Y3Rvcih0aWxlcywgbWFwU2l6ZSkge1xuICAgIHRoaXMudGlsZXMgPSB0aWxlcztcbiAgICB0aGlzLm1hcFNpemUgPSBtYXBTaXplO1xuICAgIHRoaXMudGlsZVdpZHRoID0gdGlsZXNbMF0udGlsZVdpZHRoO1xuICAgIHRoaXMudGlsZUhlaWdodCA9IHRpbGVzWzBdLnRpbGVIZWlnaHQ7XG4gICAgdGhpcy5jZWxscyA9IGJ1aWxkQ2VsbHModGhpcyk7XG4gIH1cblxuICBnZXQgbWFwQ2FudmFzKCkge1xuICAgIGlmICh0aGlzLm15TWFwQ2FudmFzID09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5teU1hcENhbnZhcyA9IGRyYXdNYXBDYW52YXModGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm15TWFwQ2FudmFzO1xuICB9XG5cbiAgbWFwQ29vcmRzRm9yQ2VsbChjZWxsQ29vcmRzKSB7XG4gICAgbGV0IHhPZmZzZXQgPSAodGhpcy5tYXBTaXplICogdGhpcy50aWxlV2lkdGgpIC8gMiAtIHRoaXMudGlsZVdpZHRoIC8gMjtcbiAgICBsZXQgbWFwWCA9IChjZWxsQ29vcmRzLnggLSBjZWxsQ29vcmRzLnkpICogKHRoaXMudGlsZVdpZHRoIC8gMikgKyB4T2Zmc2V0O1xuICAgIGxldCBtYXBZID0gKGNlbGxDb29yZHMueCArIGNlbGxDb29yZHMueSkgKiAodGhpcy50aWxlSGVpZ2h0IC8gMik7XG4gICAgcmV0dXJuIHsgeDogbWFwWCwgeTogbWFwWSB9O1xuICB9XG5cbiAgZ2V0IHRpbGVPZmZzZXRzKCkge1xuICAgIHJldHVybiB7IHg6IHRoaXMudGlsZVdpZHRoIC8gMiwgeTogdGhpcy50aWxlSGVpZ2h0IC8gMiB9O1xuICB9XG5cbiAgY2VsbEF0KGNvb3Jkcykge1xuICAgIHJldHVybiB0aGlzLmNlbGxzW2Nvb3Jkcy54XVtjb29yZHMueV07XG4gIH1cblxuICBuZWlnaGJvcnMoY29vcmRzKSB7XG4gICAgbGV0IG5laWdoYm9ycyA9IFtdO1xuICAgIGlmIChjb29yZHMueCA8IHRoaXMubWFwU2l6ZSAtIDEpIHtcbiAgICAgIG5laWdoYm9ycy5wdXNoKHRoaXMuY2VsbHNbY29vcmRzLnggKyAxXVtjb29yZHMueV0pO1xuICAgIH1cbiAgICBpZiAoY29vcmRzLnggPiAwKSB7XG4gICAgICBuZWlnaGJvcnMucHVzaCh0aGlzLmNlbGxzW2Nvb3Jkcy54IC0gMV1bY29vcmRzLnldKTtcbiAgICB9XG4gICAgaWYgKGNvb3Jkcy55IDwgdGhpcy5tYXBTaXplIC0gMSkge1xuICAgICAgbmVpZ2hib3JzLnB1c2godGhpcy5jZWxsc1tjb29yZHMueF1bY29vcmRzLnkgKyAxXSk7XG4gICAgfVxuICAgIGlmIChjb29yZHMueSA+IDApIHtcbiAgICAgIG5laWdoYm9ycy5wdXNoKHRoaXMuY2VsbHNbY29vcmRzLnhdW2Nvb3Jkcy55IC0gMV0pO1xuICAgIH1cbiAgICByZXR1cm4gbmVpZ2hib3JzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQ2VsbHMobWFwKSB7XG4gIGxldCBjZWxscyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcC5tYXBTaXplOyBpKyspIHtcbiAgICBjZWxsc1tpXSA9IFtdO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWFwLm1hcFNpemU7IGorKykge1xuICAgICAgY2VsbHNbaV1bal0gPSBuZXcgQ2VsbChtYXAudGlsZXNbcmFuZChtYXAudGlsZXMubGVuZ3RoKV0sIG1hcCwge1xuICAgICAgICB4OiBpLFxuICAgICAgICB5OiBqXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNlbGxzO1xufVxuXG5mdW5jdGlvbiBkcmF3TWFwQ2FudmFzKG1hcCkge1xuICBsZXQgbWFwQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIG1hcENhbnZhcy53aWR0aCA9IG1hcC5tYXBTaXplICogbWFwLnRpbGVXaWR0aCAtIG1hcC5tYXBTaXplO1xuICBtYXBDYW52YXMuaGVpZ2h0ID0gbWFwLm1hcFNpemUgKiBtYXAudGlsZUhlaWdodCAtIG1hcC5tYXBTaXplO1xuXG4gIGZvciAobGV0IFt4LCByb3ddIG9mIG1hcC5jZWxscy5lbnRyaWVzKCkpIHtcbiAgICBmb3IgKGxldCBbeSwgY2VsbF0gb2Ygcm93LmVudHJpZXMoKSkge1xuICAgICAgZHJhd1RpbGUobWFwLCBtYXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKSwgY2VsbC50aWxlLCB4LCB5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hcENhbnZhcztcbn1cblxuZnVuY3Rpb24gZHJhd1RpbGUobWFwLCBjb250ZXh0LCB0aWxlLCBtYXBYLCBtYXBZKSB7XG4gIGxldCBjb250ZXh0Q29vcmRzID0gbWFwLm1hcENvb3Jkc0ZvckNlbGwoeyB4OiBtYXBYLCB5OiBtYXBZIH0pO1xuICBjb250ZXh0LmRyYXdJbWFnZShcbiAgICB0aWxlLmltZyxcbiAgICBjb250ZXh0Q29vcmRzLngsXG4gICAgY29udGV4dENvb3Jkcy55LFxuICAgIG1hcC50aWxlV2lkdGgsXG4gICAgbWFwLnRpbGVIZWlnaHRcbiAgKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgQXNzZXRzIH0gZnJvbSAnLi9hc3NldF9tYW5hZ2VyJztcbmltcG9ydCBBc3NldE93bmVyIGZyb20gJy4vYXNzZXRfb3duZXInO1xuaW1wb3J0IHsgZW50aXR5TWFwTG9jYXRpb25Gcm9tQ2VsbCwgRmFjaW5nIH0gZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW50aXR5IGV4dGVuZHMgQXNzZXRPd25lciB7XG4gIGNvbnN0cnVjdG9yKGVudGl0eURlZiwgbWFwLCBicmFpbikge1xuICAgIHN1cGVyKGVudGl0eURlZi5pbWFnZVBhdGhzKTtcbiAgICB0aGlzLmZyYW1lU2l6ZSA9IGVudGl0eURlZi5mcmFtZVNpemU7XG4gICAgdGhpcy5mcmFtZU9mZnNldHMgPSBlbnRpdHlEZWYuZnJhbWVPZmZzZXRzIHx8IHsgeDogMCwgeTogMCB9O1xuICAgIHRoaXMubWFwID0gbWFwO1xuICAgIHRoaXMuY3VycmVudENlbGwgPSB0aGlzLm1hcC5jZWxsQXQoZW50aXR5RGVmLnN0YXJ0Q2VsbCB8fCB7IHg6IDAsIHk6IDAgfSk7XG4gICAgdGhpcy5teUxvY2F0aW9uID0gZW50aXR5TWFwTG9jYXRpb25Gcm9tQ2VsbChcbiAgICAgIHRoaXMuY3VycmVudENlbGwsXG4gICAgICB0aGlzLm1hcCxcbiAgICAgIHRoaXMuZnJhbWVPZmZzZXRzXG4gICAgKTtcbiAgICB0aGlzLmNlbGxQYXRoID0gW107XG4gICAgdGhpcy5icmFpbiA9IGJyYWluO1xuICAgIHRoaXMuZGVzdGluYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mYWNpbmcgPSBlbnRpdHlEZWYuZmFjaW5nO1xuICB9XG5cbiAgZ2V0IGltYWdlKCkge1xuICAgIHJldHVybiBBc3NldHMuZ2V0KHRoaXMuYXNzZXRQYXRoc1swXSk7XG4gIH1cblxuICBnZXQgbG9jYXRpb24oKSB7XG4gICAgLy8gY29uc29sZS5sb2codGhpcy5teUxvY2F0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5teUxvY2F0aW9uO1xuICB9XG5cbiAgc2V0IGxvY2F0aW9uKG5ld0xvY2F0aW9uKSB7XG4gICAgbGV0IG5ld0ZhY2luZyA9IHVuZGVmaW5lZDtcbiAgICBpZiAobmV3TG9jYXRpb24gIT0gdW5kZWZpbmVkICYmIHRoaXMubXlMb2NhdGlvbiAhPSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgbmV3TG9jYXRpb24ueCA+PSB0aGlzLm15TG9jYXRpb24ueCAmJlxuICAgICAgICBuZXdMb2NhdGlvbi55ID49IHRoaXMubXlMb2NhdGlvbi55XG4gICAgICApIHtcbiAgICAgICAgbmV3RmFjaW5nID0gRmFjaW5nLlNPVVRIRUFTVDtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIG5ld0xvY2F0aW9uLnggPj0gdGhpcy5teUxvY2F0aW9uLnggJiZcbiAgICAgICAgbmV3TG9jYXRpb24ueSA8PSB0aGlzLm15TG9jYXRpb24ueVxuICAgICAgKSB7XG4gICAgICAgIG5ld0ZhY2luZyA9IEZhY2luZy5OT1JUSEVBU1Q7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBuZXdMb2NhdGlvbi54IDw9IHRoaXMubXlMb2NhdGlvbi54ICYmXG4gICAgICAgIG5ld0xvY2F0aW9uLnkgPD0gdGhpcy5teUxvY2F0aW9uLnlcbiAgICAgICkge1xuICAgICAgICBuZXdGYWNpbmcgPSBGYWNpbmcuTk9SVEhXRVNUO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgbmV3TG9jYXRpb24ueCA8PSB0aGlzLm15TG9jYXRpb24ueCAmJlxuICAgICAgICBuZXdMb2NhdGlvbi55ID49IHRoaXMubXlMb2NhdGlvbi55XG4gICAgICApIHtcbiAgICAgICAgbmV3RmFjaW5nID0gRmFjaW5nLlNPVVRIV0VTVDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0ZhY2luZyA9IEZhY2luZy5OT1JUSEVBU1Q7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZmFjaW5nID0gbmV3RmFjaW5nO1xuICAgIHRoaXMubXlMb2NhdGlvbiA9IG5ld0xvY2F0aW9uO1xuICB9XG5cbiAgZ2V0IGZyYW1lWE9yaWdpbigpIHtcbiAgICBpZiAodGhpcy5mYWNpbmcgIT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5mYWNpbmcgKiB0aGlzLmZyYW1lU2l6ZS53aWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBnZXQgZnJhbWVZT3JpZ2luKCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmVzcG9uZFRvTW91c2UoZXZlbnRDZWxsLCBibG9ja2luZ0FuaW1hdGlvbkNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZpdHkgPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmFjdGl2aXR5ID0gdGhpcy5icmFpbi5nZXRBY3Rpdml0eShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgZXZlbnRDZWxsLFxuICAgICAgICBibG9ja2luZ0FuaW1hdGlvbkNhbGxiYWNrXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGFjdGl2aXR5RG9uZSgpIHtcbiAgICB0aGlzLmFjdGl2aXR5ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdGljaygpIHtcbiAgICBpZiAodGhpcy5hY3Rpdml0eSAhPSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuYWN0aXZpdHkoKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8vIENvZGUgZm9yIGJpbmFyeSBoZWFwIGFkYXB0ZWQgZnJvbVxuLy8gaHR0cDovL2Vsb3F1ZW50amF2YXNjcmlwdC5uZXQvMXN0X2VkaXRpb24vYXBwZW5kaXgyLmh0bWxcbi8vIGJ5IE1hcmlqbiBIYXZlcmJla2VcblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgY2xhc3MgQmluYXJ5SGVhcCB7XG4gIGNvbnN0cnVjdG9yKHNjb3JlRnVuY3Rpb24sIGVxdWFsaXR5RnVuY3Rpb24pIHtcbiAgICB0aGlzLnNjb3JlRnVuY3Rpb24gPSBzY29yZUZ1bmN0aW9uO1xuICAgIHRoaXMuZXF1YWxpdHlGdW5jdGlvbiA9IGVxdWFsaXR5RnVuY3Rpb247XG4gICAgdGhpcy5lbGVtZW50cyA9IFtdO1xuICB9XG5cbiAgZmlyc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHNbMF07XG4gIH1cblxuICBwdXNoKG5ld0VsZW1lbnQpIHtcbiAgICAvLyBBZGQgdGhlIG5ldyBlbGVtZW50IHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgIHRoaXMuZWxlbWVudHMucHVzaChuZXdFbGVtZW50KTtcbiAgICAvLyBBbGxvdyBpdCB0byBidWJibGUgdXAuXG4gICAgdGhpcy5idWJibGVVcCh0aGlzLmVsZW1lbnRzLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcG9wKCkge1xuICAgIC8vIFN0b3JlIHRoZSBmaXJzdCBlbGVtZW50IHNvIHdlIGNhbiByZXR1cm4gaXQgbGF0ZXIuXG4gICAgbGV0IGZpcnN0ID0gdGhpcy5lbGVtZW50c1swXTtcbiAgICAvLyBHZXQgdGhlIGVsZW1lbnQgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgbGV0IGxhc3QgPSB0aGlzLmVsZW1lbnRzLnBvcCgpO1xuICAgIC8vIElmIHRoZXJlIGFyZSBhbnkgZWxlbWVudHMgbGVmdCwgcHV0IHRoZSBlbmQgZWxlbWVudCBhdCB0aGVcbiAgICAvLyBzdGFydCwgYW5kIGxldCBpdCBzaW5rIGRvd24uXG4gICAgaWYgKHRoaXMuZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5lbGVtZW50c1swXSA9IGxhc3Q7XG4gICAgICB0aGlzLnNpbmtEb3duKDApO1xuICAgIH1cbiAgICByZXR1cm4gZmlyc3Q7XG4gIH1cblxuICByZW1vdmUodGFyZ2V0RWxlbWVudCkge1xuICAgIGZvciAobGV0IFtpLCBlbGVtZW50XSBvZiB0aGlzLmVsZW1lbnRzLmVudHJpZXMoKSkge1xuICAgICAgaWYgKHRoaXMuZXF1YWxpdHlGdW5jdGlvbih0YXJnZXRFbGVtZW50LCBlbGVtZW50KSkge1xuICAgICAgICBsZXQgbGFzdEVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzLnBvcCgpO1xuICAgICAgICBpZiAoIShpID09IGxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgdGhpcy5lbGVtZW50c1tpXSA9IGxhc3RFbGVtZW50O1xuICAgICAgICAgIHRoaXMuYnViYmxlVXAoaSk7XG4gICAgICAgICAgdGhpcy5zaW5rRG93bihpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuICB9XG5cbiAgaW5jbHVkZXModGFyZ2V0RWxlbWVudCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzLmluZGV4T2YodGFyZ2V0RWxlbWVudCkgIT0gLTE7XG4gIH1cblxuICBidWJibGVVcChpKSB7XG4gICAgLy8gRmV0Y2ggdGhlIGVsZW1lbnQgdGhhdCBoYXMgdG8gYmUgbW92ZWQuXG4gICAgbGV0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW2ldLFxuICAgICAgc2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oZWxlbWVudCk7XG4gICAgLy8gV2hlbiBhdCAwLCBhbiBlbGVtZW50IGNhbm5vdCBnbyB1cCBhbnkgZnVydGhlci5cbiAgICB3aGlsZSAoaSA+IDApIHtcbiAgICAgIC8vIENvbXB1dGUgdGhlIHBhcmVudCBlbGVtZW50J3MgaW5kZXgsIGFuZCBmZXRjaCBpdC5cbiAgICAgIGxldCBwYXJlbnRJID0gTWF0aC5mbG9vcigoaSArIDEpIC8gMikgLSAxLFxuICAgICAgICBwYXJlbnQgPSB0aGlzLmVsZW1lbnRzW3BhcmVudEldO1xuICAgICAgLy8gSWYgdGhlIHBhcmVudCBoYXMgYSBsZXNzZXIgc2NvcmUsIHRoaW5ncyBhcmUgaW4gb3JkZXIgYW5kIHdlXG4gICAgICAvLyBhcmUgZG9uZS5cbiAgICAgIGlmIChzY29yZSA+PSB0aGlzLnNjb3JlRnVuY3Rpb24ocGFyZW50KSkgYnJlYWs7XG4gICAgICAvLyBPdGhlcndpc2UsIHN3YXAgdGhlIHBhcmVudCB3aXRoIHRoZSBjdXJyZW50IGVsZW1lbnQgYW5kXG4gICAgICAvLyBjb250aW51ZS5cbiAgICAgIHRoaXMuZWxlbWVudHNbcGFyZW50SV0gPSBlbGVtZW50O1xuICAgICAgdGhpcy5lbGVtZW50c1tpXSA9IHBhcmVudDtcbiAgICAgIGkgPSBwYXJlbnRJO1xuICAgIH1cbiAgfVxuXG4gIHNpbmtEb3duKGkpIHtcbiAgICAvLyBMb29rIHVwIHRoZSB0YXJnZXQgZWxlbWVudCBhbmQgaXRzIHNjb3JlLlxuICAgIHZhciBsZW5ndGggPSB0aGlzLmVsZW1lbnRzLmxlbmd0aCxcbiAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW2ldLFxuICAgICAgc2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oZWxlbWVudCk7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gQ29tcHV0ZSB0aGUgaW5kaWNlcyBvZiB0aGUgY2hpbGQgZWxlbWVudHMuXG4gICAgICB2YXIgY2hpbGQyaSA9IChpICsgMSkgKiAyLFxuICAgICAgICBjaGlsZDFpID0gY2hpbGQyaSAtIDE7XG4gICAgICAvLyBUaGlzIGlzIHVzZWQgdG8gc3RvcmUgdGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCxcbiAgICAgIC8vIGlmIGFueS5cbiAgICAgIHZhciBzd2FwID0gbnVsbDtcbiAgICAgIC8vIElmIHRoZSBmaXJzdCBjaGlsZCBleGlzdHMgKGlzIGluc2lkZSB0aGUgYXJyYXkpLi4uXG4gICAgICBpZiAoY2hpbGQxaSA8IGxlbmd0aCkge1xuICAgICAgICAvLyBMb29rIGl0IHVwIGFuZCBjb21wdXRlIGl0cyBzY29yZS5cbiAgICAgICAgdmFyIGNoaWxkMSA9IHRoaXMuZWxlbWVudHNbY2hpbGQxaV0sXG4gICAgICAgICAgY2hpbGQxU2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oY2hpbGQxKTtcbiAgICAgICAgLy8gSWYgdGhlIHNjb3JlIGlzIGxlc3MgdGhhbiBvdXIgZWxlbWVudCdzLCB3ZSBuZWVkIHRvIHN3YXAuXG4gICAgICAgIGlmIChjaGlsZDFTY29yZSA8IHNjb3JlKSBzd2FwID0gY2hpbGQxaTtcbiAgICAgIH1cbiAgICAgIC8vIERvIHRoZSBzYW1lIGNoZWNrcyBmb3IgdGhlIG90aGVyIGNoaWxkLlxuICAgICAgaWYgKGNoaWxkMmkgPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoaWxkMiA9IHRoaXMuZWxlbWVudHNbY2hpbGQyaV0sXG4gICAgICAgICAgY2hpbGQyU2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oY2hpbGQyKTtcbiAgICAgICAgaWYgKGNoaWxkMlNjb3JlIDwgKHN3YXAgPT0gbnVsbCA/IHNjb3JlIDogY2hpbGQxU2NvcmUpKSBzd2FwID0gY2hpbGQyaTtcbiAgICAgIH1cblxuICAgICAgLy8gTm8gbmVlZCB0byBzd2FwIGZ1cnRoZXIsIHdlIGFyZSBkb25lLlxuICAgICAgaWYgKHN3YXAgPT0gbnVsbCkgYnJlYWs7XG5cbiAgICAgIC8vIE90aGVyd2lzZSwgc3dhcCBhbmQgY29udGludWUuXG4gICAgICB0aGlzLmVsZW1lbnRzW2ldID0gdGhpcy5lbGVtZW50c1tzd2FwXTtcbiAgICAgIHRoaXMuZWxlbWVudHNbc3dhcF0gPSBlbGVtZW50O1xuICAgICAgaSA9IHN3YXA7XG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7XG4gIGVudGl0eU1hcExvY2F0aW9uRnJvbUNlbGwsXG4gIGNvb3Jkc0VxdWFsLFxuICBhcnJheUluY2x1ZGVzQ29vcmRzXG59IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBCaW5hcnlIZWFwIH0gZnJvbSAnLi9iaW5hcnlfaGVhcCc7XG5cbmV4cG9ydCBjbGFzcyBNb2JpbGVCcmFpbiB7XG4gIGdldEFjdGl2aXR5KGVudGl0eSwgZXZlbnRDZWxsLCBibG9ja2luZ0FuaW1hdGlvbkNhbGxiYWNrKSB7XG4gICAgbGV0IHN0YXJ0Q2VsbCA9IGVudGl0eS5jdXJyZW50Q2VsbDtcbiAgICBsZXQgZW5kQ2VsbCA9IGV2ZW50Q2VsbDtcbiAgICBsZXQgY2VsbFBhdGggPSBidWlsZENlbGxQYXRoQVN0YXIoc3RhcnRDZWxsLCBlbmRDZWxsKTtcbiAgICBsZXQgZGVzdGluYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgYmxvY2tpbmdBbmltYXRpb25DYWxsYmFjayh0cnVlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGRlc3RpbmF0aW9uICE9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgbmV4dFBvc2l0aW9uID0gZ2V0TmV4dE1hcFBvc2l0aW9uKGVudGl0eSwgZGVzdGluYXRpb24pO1xuICAgICAgICBlbnRpdHkubG9jYXRpb24gPSBuZXh0UG9zaXRpb247XG4gICAgICAgIGlmIChjb29yZHNFcXVhbChlbnRpdHkubG9jYXRpb24sIGRlc3RpbmF0aW9uKSkge1xuICAgICAgICAgIGRlc3RpbmF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNlbGxQYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZW50aXR5LmN1cnJlbnRDZWxsID0gY2VsbFBhdGhbMF07XG4gICAgICAgIGRlc3RpbmF0aW9uID0gZ2V0RGVzdGluYXRpb24oZW50aXR5LCBjZWxsUGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnRpdHkuYWN0aXZpdHlEb25lKCk7XG4gICAgICAgIGJsb2NraW5nQW5pbWF0aW9uQ2FsbGJhY2soZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TmV4dE1hcFBvc2l0aW9uKGVudGl0eSwgZGVzdGluYXRpb24pIHtcbiAgbGV0IGN1cnJlbnRMb2MgPSB7IHg6IGVudGl0eS5sb2NhdGlvbi54LCB5OiBlbnRpdHkubG9jYXRpb24ueSB9O1xuICBsZXQgZHggPSBjdXJyZW50TG9jLnggLSBkZXN0aW5hdGlvbi54LFxuICAgIGR5ID0gY3VycmVudExvYy55IC0gZGVzdGluYXRpb24ueTtcbiAgbGV0IGRpc3QgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICBsZXQgdmVsWCA9IChkeCAvIGRpc3QpICogNTtcbiAgbGV0IHZlbFkgPSAoZHkgLyBkaXN0KSAqIDU7XG4gIGlmIChNYXRoLmFicyhkeCkgPCBNYXRoLmFicyh2ZWxYKSkge1xuICAgIHZlbFggPSBkeDtcbiAgfVxuICBpZiAoTWF0aC5hYnMoZHkpIDwgTWF0aC5hYnModmVsWSkpIHtcbiAgICB2ZWxZID0gZHk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiAoY3VycmVudExvYy54IC09IHZlbFgpLFxuICAgIHk6IChjdXJyZW50TG9jLnkgLT0gdmVsWSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVzdGluYXRpb24oZW50aXR5LCBjZWxsUGF0aCkge1xuICBsZXQgbmV4dENlbGxEZXN0aW5hdGlvbiA9IGNlbGxQYXRoLnNoaWZ0KCk7XG4gIGxldCBuZXh0RGVzdGluYXRpb24gPSB1bmRlZmluZWQ7XG4gIGlmIChuZXh0Q2VsbERlc3RpbmF0aW9uICE9IHVuZGVmaW5lZCkge1xuICAgIG5leHREZXN0aW5hdGlvbiA9IGVudGl0eU1hcExvY2F0aW9uRnJvbUNlbGwoXG4gICAgICBuZXh0Q2VsbERlc3RpbmF0aW9uLFxuICAgICAgZW50aXR5Lm1hcCxcbiAgICAgIGVudGl0eS5mcmFtZU9mZnNldHNcbiAgICApO1xuICB9XG4gIHJldHVybiBuZXh0RGVzdGluYXRpb247XG59XG5cbi8vIFVzZXMgQnJlbnNlbmhhbSdzIGxpbmUgYWxnb3JpdGhtXG5mdW5jdGlvbiBidWlsZENlbGxQYXRoKHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHBhdGggPSBbXTtcblxuICBsZXQgY3VycmVudFggPSBzdGFydC54LFxuICAgIGN1cnJlbnRZID0gc3RhcnQueTtcbiAgbGV0IGRlbHRhWCA9IE1hdGguYWJzKGVuZC54IC0gc3RhcnQueCksXG4gICAgZGVsdGFZID0gTWF0aC5hYnMoZW5kLnkgLSBzdGFydC55KTtcbiAgbGV0IHNsb3BlWCA9IHN0YXJ0LnggPCBlbmQueCA/IDEgOiAtMSxcbiAgICBzbG9wZVkgPSBzdGFydC55IDwgZW5kLnkgPyAxIDogLTE7XG4gIGxldCBlcnIgPSBkZWx0YVggLSBkZWx0YVk7XG5cbiAgd2hpbGUgKGN1cnJlbnRYICE9IGVuZC54IHx8IGN1cnJlbnRZICE9IGVuZC55KSB7XG4gICAgbGV0IGVycjIgPSAyICogZXJyO1xuICAgIGlmIChlcnIyID4gZGVsdGFZICogLTEpIHtcbiAgICAgIGVyciAtPSBkZWx0YVk7XG4gICAgICBjdXJyZW50WCArPSBzbG9wZVg7XG4gICAgfSBlbHNlIGlmIChlcnIyIDwgZGVsdGFYKSB7XG4gICAgICBlcnIgKz0gZGVsdGFYO1xuICAgICAgY3VycmVudFkgKz0gc2xvcGVZO1xuICAgIH1cbiAgICBwYXRoLnB1c2goeyB4OiBjdXJyZW50WCwgeTogY3VycmVudFkgfSk7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQ2VsbFBhdGhBU3RhcihzdGFydCwgZW5kKSB7XG4gIC8vIGNvbnNvbGUubG9nKCdzdGFydCBidWlsZENlbGxQYXRoQVN0YXInKTtcbiAgbGV0IG9wZW4gPSBuZXcgQmluYXJ5SGVhcChcbiAgICBhID0+IHtcbiAgICAgIHJldHVybiBhLmY7XG4gICAgfSxcbiAgICAoYSwgYikgPT4ge1xuICAgICAgcmV0dXJuIGNvb3Jkc0VxdWFsKGEsIGIpO1xuICAgIH1cbiAgKTtcbiAgb3Blbi5wdXNoKG5ldyBHcmFwaE5vZGUoc3RhcnQpKTtcbiAgbGV0IGNsb3NlZCA9IFtdO1xuICAvLyBjb25zb2xlLmxvZyhgZW5kOiAke2VuZC5jb25zdHJ1Y3Rvci5uYW1lfWApO1xuICAvLyBjb25zb2xlLmxvZyhgICB4JHtlbmQueH0sIHkke2VuZC55fWApO1xuICB3aGlsZSAob3Blbi5zaXplKCkgPiAwKSB7XG4gICAgbGV0IGN1cnJlbnROb2RlID0gb3Blbi5wb3AoKTtcbiAgICBjbG9zZWQucHVzaChjdXJyZW50Tm9kZSk7XG4gICAgLy8gY29uc29sZS5sb2coJycpO1xuICAgIC8vIGNvbnNvbGUubG9nKCdDb25zaWRlcmluZy4uLi4nKTtcbiAgICAvLyBjb25zb2xlLmxvZyhjdXJyZW50Tm9kZS5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAvLyBjb25zb2xlLmxvZyhgICB4JHtjdXJyZW50Tm9kZS54fSwgeSR7Y3VycmVudE5vZGUueX0sIGYke2N1cnJlbnROb2RlLmZ9YCk7XG4gICAgaWYgKGNvb3Jkc0VxdWFsKGN1cnJlbnROb2RlLCBlbmQpKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcbiAgICAgIC8vICAgYGN1cnJlbnROb2RlIHgke2N1cnJlbnROb2RlLnh9LCB5JHtjdXJyZW50Tm9kZS55fSBpcyBlbmQgbm9kZSB4JHtcbiAgICAgIC8vICAgICBlbmQueFxuICAgICAgLy8gICB9LCB5JHtlbmQueX1gXG4gICAgICAvLyApO1xuICAgICAgcmV0dXJuIGJ1aWxkUGF0aChjdXJyZW50Tm9kZSk7XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKGBjbG9zZWQ6YCk7XG4gICAgLy8gZm9yIChsZXQgY2xvc2VkTm9kZSBvZiBjbG9zZWQpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhcbiAgICAvLyAgIGAgICR7Y2xvc2VkTm9kZS5jb25zdHJ1Y3Rvci5uYW1lfTogeCR7Y2xvc2VkTm9kZS54fSwgeSR7Y2xvc2VkTm9kZS55fWBcbiAgICAvLyApO1xuICAgIC8vIH1cbiAgICBsZXQgbmVpZ2hib3JzID0gY3VycmVudE5vZGUubmVpZ2hib3JzO1xuICAgIGZvciAobGV0IG5laWdoYm9yIG9mIG5laWdoYm9ycykge1xuICAgICAgLy8gY29uc29sZS5sb2coXG4gICAgICAvLyAgIGBDb25zaWRlcmluZyBuZWlnaGJvciAke25laWdoYm9yLmNvbnN0cnVjdG9yLm5hbWV9IHgke25laWdoYm9yLnh9LCB5JHtcbiAgICAgIC8vICAgICBuZWlnaGJvci55XG4gICAgICAvLyAgIH1gXG4gICAgICAvLyApO1xuICAgICAgaWYgKCFhcnJheUluY2x1ZGVzQ29vcmRzKGNsb3NlZCwgbmVpZ2hib3IpKSB7XG4gICAgICAgIGxldCBnID0gY3VycmVudE5vZGUuZyArIDE7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGAgIG5laWdoYm9yIGhhcyBnJHtuZWlnaGJvci5nfSwgZiR7bmVpZ2hib3IuZn1gKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXG4gICAgICAgIC8vICAgYCAgY2xvc2VkIGRvZXMgbm90IGluY2x1ZGUgbmVpZ2hib3IgeCR7bmVpZ2hib3IueH0sIHkke25laWdoYm9yLnl9YFxuICAgICAgICAvLyApO1xuICAgICAgICBpZiAoIW9wZW4uaW5jbHVkZXMobmVpZ2hib3IpKSB7XG4gICAgICAgICAgb3Blbi5wdXNoKG5laWdoYm9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChnID49IG5laWdoYm9yLmcpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBuZWlnaGJvci5wYXJlbnQgPSBjdXJyZW50Tm9kZTtcbiAgICAgICAgbmVpZ2hib3IuZiA9IG5laWdoYm9yLmcgKyBtYW5oYXR0ZW5EaXN0YW5jZShuZWlnaGJvciwgZW5kKTtcbiAgICAgICAgY29uc29sZS5sb2cobmVpZ2hib3IuZik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUGF0aChlbmROb2RlKSB7XG4gIGxldCBwYXRoID0gW107XG4gIHdoaWxlIChlbmROb2RlLnBhcmVudCkge1xuICAgIHBhdGgucHVzaChlbmROb2RlLmNlbGwpO1xuICAgIGVuZE5vZGUgPSBlbmROb2RlLnBhcmVudDtcbiAgfVxuICByZXR1cm4gcGF0aC5yZXZlcnNlKCk7XG59XG5cbmZ1bmN0aW9uIG1hbmhhdHRlbkRpc3RhbmNlKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIE1hdGguYWJzKHN0YXJ0LnggLSBlbmQueCkgKyBNYXRoLmFicyhzdGFydC55IC0gZW5kLnkpO1xufVxuXG5jbGFzcyBHcmFwaE5vZGUge1xuICBjb25zdHJ1Y3RvcihjZWxsKSB7XG4gICAgdGhpcy5jZWxsID0gY2VsbDtcbiAgICB0aGlzLmYgPSAwO1xuICB9XG4gIGdldCBuZWlnaGJvcnMoKSB7XG4gICAgaWYgKHRoaXMubXlOZWlnaGJvcnMgPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5jZWxsLm5laWdoYm9ycy5tYXAobmVpZ2hib3IgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IEdyYXBoTm9kZShuZWlnaGJvcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubXlOZWlnaGJvcnM7XG4gIH1cbiAgc2V0IGcobmV3Rykge1xuICAgIC8qIG5vIG9wLCBnIGlzIGNvbXB1dGVkIGZyb20gcGFyZW50LmcgKi9cbiAgfVxuICBnZXQgZygpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQgIT0gdW5kZWZpbmVkID8gdGhpcy5wYXJlbnQuZyArIDEgOiAwO1xuICB9XG4gIGdldCBjb29yZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2VsbC5jb29yZHM7XG4gIH1cbiAgZ2V0IHgoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2VsbC5jb29yZHMueDtcbiAgfVxuICBnZXQgeSgpIHtcbiAgICByZXR1cm4gdGhpcy5jZWxsLmNvb3Jkcy55O1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBUaWxlIGZyb20gJy4vdGlsZSc7XG5pbXBvcnQgTWFwIGZyb20gJy4vbWFwJztcbmltcG9ydCBFbnRpdHkgZnJvbSAnLi9lbnRpdHknO1xuaW1wb3J0IHsgQXNzZXRzIH0gZnJvbSAnLi9hc3NldF9tYW5hZ2VyJztcbmltcG9ydCB7IElucHV0IH0gZnJvbSAnLi9pbnB1dCc7XG5pbXBvcnQgeyBNb2JpbGVCcmFpbiB9IGZyb20gJy4vYnJhaW4nO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2VuZSB7XG4gIGNvbnN0cnVjdG9yKHNjZW5lRGVmLCB2aWV3cG9ydCwgdmlld3BvcnREaW1lbnNpb25zLCBsb2FkQ29tcGxldGVDYWxsYmFjaykge1xuICAgIGxldCB0aWxlcyA9IHNjZW5lRGVmLm1hcERlZi50aWxlSW1hZ2VQYXRocy5tYXAodGlsZUltYWdlUGF0aCA9PiB7XG4gICAgICByZXR1cm4gbmV3IFRpbGUoW3RpbGVJbWFnZVBhdGhdKTtcbiAgICB9KTtcblxuICAgIHRoaXMubWFwID0gbmV3IE1hcCh0aWxlcywgc2NlbmVEZWYubWFwRGVmLm1hcFNpemUpO1xuXG4gICAgdGhpcy5tb2JpbGVzID0gc2NlbmVEZWYubW9iaWxlRGVmcy5tYXAobW9iaWxlRGVmID0+IHtcbiAgICAgIHJldHVybiBuZXcgRW50aXR5KG1vYmlsZURlZiwgdGhpcy5tYXAsIG5ldyBNb2JpbGVCcmFpbigpKTtcbiAgICB9KTtcbiAgICB0aGlzLmFjdGl2ZU1vYmlsZSA9IHRoaXMubW9iaWxlc1swXTtcbiAgICB0aGlzLnByb3BzID0gc2NlbmVEZWYucHJvcERlZnMubWFwKHByb3BEZWYgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBFbnRpdHkocHJvcERlZiwgdGhpcy5tYXApO1xuICAgIH0pO1xuXG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIHRoaXMudmlld3BvcnREaW1lbnNpb25zID0gdmlld3BvcnREaW1lbnNpb25zO1xuXG4gICAgQXNzZXRzLmxvYWRBc3NldHMoWy4uLnRpbGVzLCAuLi50aGlzLm1vYmlsZXMsIC4uLnRoaXMucHJvcHNdLCAoKSA9PiB7XG4gICAgICB0aGlzLnZpZXdwb3J0T2Zmc2V0RGltZW5zaW9ucyA9IHtcbiAgICAgICAgeDogdGhpcy5tYXAubWFwQ2FudmFzLndpZHRoIC8gMiAtIHZpZXdwb3J0RGltZW5zaW9ucy54IC8gMixcbiAgICAgICAgeTogdGhpcy5tYXAubWFwQ2FudmFzLmhlaWdodCAvIDIgLSB2aWV3cG9ydERpbWVuc2lvbnMueSAvIDJcbiAgICAgIH07XG4gICAgICBsb2FkQ29tcGxldGVDYWxsYmFjaygpO1xuICAgIH0pO1xuXG4gICAgdGhpcy53YWl0aW5nT25BbmltYXRpb24gPSBmYWxzZTtcbiAgfVxuXG4gIHRpY2soKSB7XG4gICAgbGV0IG1vdXNlRXZlbnQgPSBJbnB1dC5nZXRNb3VzZUV2ZW50KCk7XG4gICAgaWYgKG1vdXNlRXZlbnQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgZXZlbnRWaWV3cG9ydFBvc2l0aW9uID0gZ2V0RXZlbnRWaWV3cG9ydFBvc2l0aW9uKFxuICAgICAgICB0aGlzLnZpZXdwb3J0LFxuICAgICAgICBtb3VzZUV2ZW50XG4gICAgICApO1xuICAgICAgbGV0IGV2ZW50TWFwUG9zaXRpb24gPSBnZXRDdXJzb3JNYXBQb3NpdGlvbihcbiAgICAgICAgdGhpcy52aWV3cG9ydE9mZnNldERpbWVuc2lvbnMsXG4gICAgICAgIGV2ZW50Vmlld3BvcnRQb3NpdGlvblxuICAgICAgKTtcbiAgICAgIGxldCBjZWxsUG9zaXRpb24gPSBnZXRDdXJzb3JDZWxsUG9zaXRpb24odGhpcy5tYXAsIGV2ZW50TWFwUG9zaXRpb24pO1xuXG4gICAgICBpZiAoIXRoaXMud2FpdGluZ09uQW5pbWF0aW9uKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlTW9iaWxlLnJlc3BvbmRUb01vdXNlKFxuICAgICAgICAgIHRoaXMubWFwLmNlbGxBdChjZWxsUG9zaXRpb24pLFxuICAgICAgICAgIHNob3VsZFdhaXQgPT4ge1xuICAgICAgICAgICAgdGhpcy53YWl0aW5nT25BbmltYXRpb24gPSBzaG91bGRXYWl0O1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodGhpcy5tb2JpbGVzLnNsaWNlKC0xKVswXSA9PSB0aGlzLmFjdGl2ZU1vYmlsZSkge1xuICAgICAgICAgIHRoaXMuYWN0aXZlTW9iaWxlID0gdGhpcy5tb2JpbGVzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYWN0aXZlTW9iaWxlID0gdGhpcy5tb2JpbGVzW1xuICAgICAgICAgICAgdGhpcy5tb2JpbGVzLmluZGV4T2YodGhpcy5hY3RpdmVNb2JpbGUpICsgMVxuICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm1vYmlsZXMuZm9yRWFjaChtb2JpbGUgPT4ge1xuICAgICAgbW9iaWxlLnRpY2soKTtcbiAgICB9KTtcbiAgICB0aGlzLnByb3BzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICBwcm9wLnRpY2soKTtcbiAgICB9KTtcblxuICAgIGxldCBjb250ZXh0ID0gdGhpcy52aWV3cG9ydC5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNvbnRleHQuY2xlYXJSZWN0KFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICB0aGlzLnZpZXdwb3J0RGltZW5zaW9ucy54LFxuICAgICAgdGhpcy52aWV3cG9ydERpbWVuc2lvbnMueVxuICAgICk7XG4gICAgY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICB0aGlzLm1hcC5tYXBDYW52YXMsXG4gICAgICB0aGlzLnZpZXdwb3J0T2Zmc2V0RGltZW5zaW9ucy54LFxuICAgICAgdGhpcy52aWV3cG9ydE9mZnNldERpbWVuc2lvbnMueSxcbiAgICAgIHRoaXMudmlld3BvcnREaW1lbnNpb25zLngsXG4gICAgICB0aGlzLnZpZXdwb3J0RGltZW5zaW9ucy55LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICB0aGlzLnZpZXdwb3J0RGltZW5zaW9ucy54LFxuICAgICAgdGhpcy52aWV3cG9ydERpbWVuc2lvbnMueVxuICAgICk7XG5cbiAgICB0aGlzLm1vYmlsZXMuZm9yRWFjaChtb2JpbGUgPT4ge1xuICAgICAgY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAgIG1vYmlsZS5pbWFnZSxcbiAgICAgICAgbW9iaWxlLmZyYW1lWE9yaWdpbixcbiAgICAgICAgbW9iaWxlLmZyYW1lWU9yaWdpbixcbiAgICAgICAgbW9iaWxlLmZyYW1lU2l6ZS53aWR0aCxcbiAgICAgICAgbW9iaWxlLmZyYW1lU2l6ZS5oZWlnaHQsXG4gICAgICAgIG1vYmlsZS5sb2NhdGlvbi54IC0gdGhpcy52aWV3cG9ydE9mZnNldERpbWVuc2lvbnMueCxcbiAgICAgICAgbW9iaWxlLmxvY2F0aW9uLnkgLSB0aGlzLnZpZXdwb3J0T2Zmc2V0RGltZW5zaW9ucy55LFxuICAgICAgICBtb2JpbGUuZnJhbWVTaXplLndpZHRoLFxuICAgICAgICBtb2JpbGUuZnJhbWVTaXplLmhlaWdodFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRoaXMucHJvcHMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICBwcm9wLmltYWdlLFxuICAgICAgICBwcm9wLmZyYW1lWE9yaWdpbixcbiAgICAgICAgcHJvcC5mcmFtZVlPcmlnaW4sXG4gICAgICAgIHByb3AuZnJhbWVTaXplLndpZHRoLFxuICAgICAgICBwcm9wLmZyYW1lU2l6ZS5oZWlnaHQsXG4gICAgICAgIHByb3AubG9jYXRpb24ueCAtIHRoaXMudmlld3BvcnRPZmZzZXREaW1lbnNpb25zLngsXG4gICAgICAgIHByb3AubG9jYXRpb24ueSAtIHRoaXMudmlld3BvcnRPZmZzZXREaW1lbnNpb25zLnksXG4gICAgICAgIHByb3AuZnJhbWVTaXplLndpZHRoLFxuICAgICAgICBwcm9wLmZyYW1lU2l6ZS5oZWlnaHRcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBJbnB1dC5yZXNldElucHV0cygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEN1cnNvck1hcFBvc2l0aW9uKHZpZXdPZmZzZXRzLCBwb3NpdGlvbikge1xuICByZXR1cm4geyB4OiB2aWV3T2Zmc2V0cy54ICsgcG9zaXRpb24ueCwgeTogdmlld09mZnNldHMueSArIHBvc2l0aW9uLnkgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q3Vyc29yQ2VsbFBvc2l0aW9uKG1hcCwgcG9zaXRpb24pIHtcbiAgbGV0IGhhbGZUaWxlV2lkdGggPSBtYXAudGlsZVdpZHRoIC8gMjtcbiAgbGV0IGhhbGZUaWxlSGVpZ2h0ID0gbWFwLnRpbGVIZWlnaHQgLyAyO1xuICBsZXQgaGFsZk1hcFNpemUgPSBtYXAubWFwU2l6ZSAvIDI7XG4gIGxldCBjZWxsWCA9XG4gICAgKHBvc2l0aW9uLnggLyBoYWxmVGlsZVdpZHRoICsgcG9zaXRpb24ueSAvIGhhbGZUaWxlSGVpZ2h0KSAvIDIgLVxuICAgIGhhbGZNYXBTaXplO1xuICBsZXQgY2VsbFkgPVxuICAgIChwb3NpdGlvbi55IC8gaGFsZlRpbGVIZWlnaHQgLSBwb3NpdGlvbi54IC8gaGFsZlRpbGVXaWR0aCkgLyAyICtcbiAgICBoYWxmTWFwU2l6ZTtcbiAgcmV0dXJuIHsgeDogTWF0aC5mbG9vcihjZWxsWCksIHk6IE1hdGguZmxvb3IoY2VsbFkpIH07XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50Vmlld3BvcnRQb3NpdGlvbih2aWV3cG9ydCwgZXZlbnQpIHtcbiAgbGV0IHJlY3QgPSB2aWV3cG9ydC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgbGV0IHggPSBldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICBsZXQgeSA9IGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcDtcbiAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgY29uc3Qgc2NlbmVEZWYgPSB7XG4gIG1hcERlZjoge1xuICAgIG1hcFNpemU6IDEwLFxuICAgIHRpbGVJbWFnZVBhdGhzOiBbXG4gICAgICAnLi9zcmMvaW1nL2dyb3VuZF90aWxlcy9icmlja3BhdmVyczIucG5nJyxcbiAgICAgICcuL3NyYy9pbWcvZ3JvdW5kX3RpbGVzL2NvbmNyZXRlMzY4YS5wbmcnLFxuICAgICAgJy4vc3JjL2ltZy9ncm91bmRfdGlsZXMvY3JldGVicmljazk3MC5wbmcnLFxuICAgICAgJy4vc3JjL2ltZy9ncm91bmRfdGlsZXMvZGlydC5wbmcnLFxuICAgICAgJy4vc3JjL2ltZy9ncm91bmRfdGlsZXMvZGlydHNhbmQyLnBuZycsXG4gICAgICAnLi9zcmMvaW1nL2dyb3VuZF90aWxlcy9yb2NrLnBuZycsXG4gICAgICAnLi9zcmMvaW1nL2dyb3VuZF90aWxlcy9zbm93LnBuZycsXG4gICAgICAnLi9zcmMvaW1nL2dyb3VuZF90aWxlcy9zdG9uZS5wbmcnXG4gICAgXVxuICB9LFxuICBtb2JpbGVEZWZzOiBbXG4gICAge1xuICAgICAgaW1hZ2VQYXRoczogWycuL3NyYy9pbWcvbW9iaWxlcy84d2F5X21vYmlsZS5wbmcnXSxcbiAgICAgIHN0YXJ0Q2VsbDogeyB4OiAzLCB5OiAzIH0sXG4gICAgICBmcmFtZVNpemU6IHsgd2lkdGg6IDYwLCBoZWlnaHQ6IDExMCB9LFxuICAgICAgZnJhbWVPZmZzZXRzOiB7IHg6IDMwLCB5OiAxMTAgfVxuICAgIH0sXG4gICAge1xuICAgICAgaW1hZ2VQYXRoczogWycuL3NyYy9pbWcvbW9iaWxlcy84d2F5X21vYmlsZS5wbmcnXSxcbiAgICAgIHN0YXJ0Q2VsbDogeyB4OiA1LCB5OiA0IH0sXG4gICAgICBmcmFtZVNpemU6IHsgd2lkdGg6IDYwLCBoZWlnaHQ6IDExMCB9LFxuICAgICAgZnJhbWVPZmZzZXRzOiB7IHg6IDMwLCB5OiAxMTAgfVxuICAgIH0sXG4gICAge1xuICAgICAgaW1hZ2VQYXRoczogWycuL3NyYy9pbWcvbW9iaWxlcy84d2F5X21vYmlsZS5wbmcnXSxcbiAgICAgIHN0YXJ0Q2VsbDogeyB4OiAzLCB5OiA2IH0sXG4gICAgICBmcmFtZVNpemU6IHsgd2lkdGg6IDYwLCBoZWlnaHQ6IDExMCB9LFxuICAgICAgZnJhbWVPZmZzZXRzOiB7IHg6IDMwLCB5OiAxMTAgfVxuICAgIH1cbiAgXSxcbiAgcHJvcERlZnM6IFtcbiAgICB7XG4gICAgICBpbWFnZVBhdGhzOiBbJy4vc3JjL2ltZy9wcm9wcy9zdGF0dWUxLTAxLnBuZyddLFxuICAgICAgc3RhcnRDZWxsOiB7IHg6IDUsIHk6IDUgfSxcbiAgICAgIGZyYW1lU2l6ZTogeyB3aWR0aDogMTI4LCBoZWlnaHQ6IDEyOCB9LFxuICAgICAgZnJhbWVPZmZzZXRzOiB7IHg6IDAsIHk6IDE0IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGltYWdlUGF0aHM6IFsnLi9zcmMvaW1nL3Byb3BzL3N0YXR1ZTEtMDIucG5nJ10sXG4gICAgICBzdGFydENlbGw6IHsgeDogMCwgeTogMyB9LFxuICAgICAgZnJhbWVTaXplOiB7IHdpZHRoOiAxMjgsIGhlaWdodDogMTI4IH0sXG4gICAgICBmcmFtZU9mZnNldHM6IHsgeDogMCwgeTogMTQgfVxuICAgIH0sXG4gICAge1xuICAgICAgaW1hZ2VQYXRoczogWycuL3NyYy9pbWcvcHJvcHMvc3RhdHVlMS0wMy5wbmcnXSxcbiAgICAgIHN0YXJ0Q2VsbDogeyB4OiA0LCB5OiAxIH0sXG4gICAgICBmcmFtZVNpemU6IHsgd2lkdGg6IDEyOCwgaGVpZ2h0OiAxMjggfSxcbiAgICAgIGZyYW1lT2Zmc2V0czogeyB4OiAwLCB5OiAxNCB9XG4gICAgfSxcbiAgICB7XG4gICAgICBpbWFnZVBhdGhzOiBbJy4vc3JjL2ltZy9wcm9wcy9zdGF0dWUxLTA0LnBuZyddLFxuICAgICAgc3RhcnRDZWxsOiB7IHg6IDUsIHk6IDEgfSxcbiAgICAgIGZyYW1lU2l6ZTogeyB3aWR0aDogMTI4LCBoZWlnaHQ6IDEyOCB9LFxuICAgICAgZnJhbWVPZmZzZXRzOiB7IHg6IDAsIHk6IDE0IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGltYWdlUGF0aHM6IFsnLi9zcmMvaW1nL3Byb3BzL3N0YXR1ZTEtMDIucG5nJ10sXG4gICAgICBzdGFydENlbGw6IHsgeDogNiwgeTogMCB9LFxuICAgICAgZnJhbWVTaXplOiB7IHdpZHRoOiAxMjgsIGhlaWdodDogMTI4IH0sXG4gICAgICBmcmFtZU9mZnNldHM6IHsgeDogMCwgeTogMTQgfVxuICAgIH0sXG4gICAge1xuICAgICAgaW1hZ2VQYXRoczogWycuL3NyYy9pbWcvcHJvcHMvc3RhdHVlMS0wMy5wbmcnXSxcbiAgICAgIHN0YXJ0Q2VsbDogeyB4OiA3LCB5OiA5IH0sXG4gICAgICBmcmFtZVNpemU6IHsgd2lkdGg6IDEyOCwgaGVpZ2h0OiAxMjggfSxcbiAgICAgIGZyYW1lT2Zmc2V0czogeyB4OiAwLCB5OiAxNCB9XG4gICAgfVxuICBdXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgJy4vc3R5bGVzL2luZGV4LmNzcyc7XG5cbmltcG9ydCB7IElucHV0IH0gZnJvbSAnLi9pbnB1dCc7XG5pbXBvcnQgU2NlbmUgZnJvbSAnLi9zY2VuZSc7XG5pbXBvcnQgeyBzY2VuZURlZiB9IGZyb20gJy4vc2NlbmVfZGVmaW5pdGlvbic7XG5pbXBvcnQgeyBCaW5hcnlIZWFwIH0gZnJvbSAnLi9iaW5hcnlfaGVhcCc7XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJ1Byb3htYSBSZXZlcmllIGFwcHJvYWNoZXMhJyk7XG5cbiAgLy8gY29uc29sZS5sb2coJ3Rlc3RpbmcgQmluYXJ5SGVhcCcpO1xuICAvLyBsZXQgaGVhcCA9IG5ldyBCaW5hcnlIZWFwKFxuICAvLyAgIGVsID0+IHtcbiAgLy8gICAgIHJldHVybiBlbDtcbiAgLy8gICB9LFxuICAvLyAgIChhLCBiKSA9PiB7XG4gIC8vICAgICByZXR1cm4gYSA9PSBiO1xuICAvLyAgIH1cbiAgLy8gKTtcbiAgLy8gZm9yIChsZXQgZW50cnkgb2YgWzEwLCAzLCA0LCA4LCAyLCA5LCA3LCAxLCAyLCA2LCA1XSkge1xuICAvLyAgIGhlYXAucHVzaChlbnRyeSk7XG4gIC8vIH1cbiAgLy8gaGVhcC5yZW1vdmUoMik7XG4gIC8vIHdoaWxlIChoZWFwLnNpemUoKSA+IDApIHtcbiAgLy8gICBjb25zb2xlLmxvZyhoZWFwLnBvcCgpKTtcbiAgLy8gfVxuXG4gIGxldCB0aWNrTGVuZ3RoID0gMjA7XG5cbiAgdmFyIHZpZXdwb3J0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3ZpZXdwb3J0LWNhbnZhcycpO1xuICBsZXQgdmlld3BvcnREaW1lbnNpb25zID0geyB4OiA2MDAsIHk6IDQwMCB9O1xuICB2aWV3cG9ydC53aWR0aCA9IHZpZXdwb3J0RGltZW5zaW9ucy54O1xuICB2aWV3cG9ydC5oZWlnaHQgPSB2aWV3cG9ydERpbWVuc2lvbnMueTtcblxuICBsZXQgc2NlbmUgPSBuZXcgU2NlbmUoc2NlbmVEZWYsIHZpZXdwb3J0LCB2aWV3cG9ydERpbWVuc2lvbnMsICgpID0+IHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRpY2soKTtcbiAgICB9LCAwKTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gdGljaygpIHtcbiAgICBzY2VuZS50aWNrKCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aWNrKCk7XG4gICAgfSwgdGlja0xlbmd0aCk7XG4gIH1cblxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZXZlbnQgPT4ge1xuICAgIElucHV0LmtleURvd24oZXZlbnQua2V5KTtcbiAgfSk7XG5cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBldmVudCA9PiB7XG4gICAgSW5wdXQua2V5VXAoZXZlbnQua2V5KTtcbiAgfSk7XG5cbiAgdmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGV2ZW50ID0+IHtcbiAgICBJbnB1dC5tb3VzZVVwKGV2ZW50KTtcbiAgfSk7XG59KTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")},,function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zdHlsZXMvaW5kZXguY3NzPzU5ZDAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n")}]);