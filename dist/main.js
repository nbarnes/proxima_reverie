!function(t){var n={};function e(l){if(n[l])return n[l].exports;var g=n[l]={i:l,l:!1,exports:{}};return t[l].call(g.exports,g,g.exports,e),g.l=!0,g.exports}e.m=t,e.c=n,e.d=function(t,n,l){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:l})},e.r=function(t){Object.defineProperty(t,"__esModule",{value:!0})},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e.p="",e(e.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./src/styles/index.css\nvar styles = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./src/asset_manager.js\n\n\n\nconst Assets = (function() {\n\n  let assets = {};\n\n  function loadAssets(assetOwners, callback) {\n    let tempAssetPaths = []\n    for (let assetOwner of assetOwners) {\n      tempAssetPaths = tempAssetPaths.concat(assetOwner.assetPaths);\n    }\n    let assetPaths = [... new Set(tempAssetPaths)];\n\n    let assetsRemaining = assetPaths.length;\n    for (let assetPath of assetPaths) {\n\n      let asset = new Image();\n      asset.onload = function() {\n        assets[assetPath] = asset;\n        assetsRemaining--;\n        if (assetsRemaining <= 0) {\n          callback();\n        }\n      };\n      asset.src = assetPath;\n    }\n  }\n\n  function get(assetPath) {\n    return assets[assetPath];\n  }\n\n  return {\n    loadAssets: loadAssets,\n    get: get\n  }\n\n})();\n\n// CONCATENATED MODULE: ./src/asset_owner.js\n\n\n\nclass AssetOwner {\n\n  constructor(assetPaths) {\n    this.assetPaths = assetPaths;\n  }\n\n}\n\n// CONCATENATED MODULE: ./src/tile.js\n\n\n\n\n\n\nclass tile_Tile extends AssetOwner {\n\n  constructor(assetPaths) {\n    super(assetPaths);\n    this.tileWidth = 128;\n    this.tileHeight = 64;\n    this.imageFrameIndex = 0;\n  }\n\n  get img() {\n    return Assets.get(this.assetPaths[this.imageFrameIndex]);\n  }\n\n}\n\n// CONCATENATED MODULE: ./src/util.js\n\n\n\nconst tileImagePaths = [\n  './src/img/ground_tiles/brickpavers2.png',\n  './src/img/ground_tiles/concrete368a.png',\n  './src/img/ground_tiles/cretebrick970.png',\n  './src/img/ground_tiles/dirt.png',\n  './src/img/ground_tiles/dirtsand2.png',\n  './src/img/ground_tiles/rock.png',\n  './src/img/ground_tiles/snow.png',\n  './src/img/ground_tiles/stone.png'\n];\n\nconst mobileSpritePaths = [\n  './src/img/mobiles/8way_mobile.png'\n]\n\nconst rand = (max) => {\n  return Math.floor(Math.random() * Math.floor(max));\n}\n\n// CONCATENATED MODULE: ./src/map.js\n\n\n\n\n\nclass Map {\n\n  constructor(tiles, mapSize) {\n    this.tiles = tiles;\n    this.mapSize = mapSize;\n    this.tileWidth = tiles[0].tileWidth;\n    this.tileHeight = tiles[0].tileHeight;\n    this.mapDef = buildMapDef(this);\n  }\n\n  get mapCanvas() {\n    if (this.myMapCanvas == undefined) {\n      this.myMapCanvas = drawMapCanvas(this);\n    }\n    return this.myMapCanvas;\n  }\n\n};\n\nfunction buildMapDef(map) {\n  let mapDef = [];\n  for (let i = 0; i < map.mapSize; i++) {\n    mapDef[i] = [];\n    for (let j = 0; j < map.mapSize; j++) {\n      mapDef[i][j] = map.tiles[rand(map.tiles.length)];\n    }\n  }\n  return mapDef;\n}\n\nfunction drawMapCanvas(map) {\n  console.log('bob');\n  let mapCanvas = document.createElement(\"canvas\");\n  mapCanvas.width = map.mapSize * map.tileWidth - map.mapSize;\n  mapCanvas.height = map.mapSize * map.tileHeight - map.mapSize;\n\n  for (let [x, row] of map.mapDef.entries()) {\n    for (let [y, tile] of row.entries()) {\n      drawTile(map, mapCanvas.getContext(\"2d\"), tile, x, y);\n    }\n  }\n  return mapCanvas;\n}\n\nfunction drawTile(map, context, tile, mapX, mapY) {\n  let xOffset = ((map.mapSize * map.tileWidth) / 2) - (map.tileWidth / 2);\n  let contextX = ((mapX - mapY) * (map.tileWidth / 2)) - mapX + xOffset;\n  let contextY = (mapX + mapY) * (map.tileHeight / 2) - mapY;\n  context.drawImage(tile.img, contextX, contextY, map.tileWidth, map.tileHeight);\n}\n\n// CONCATENATED MODULE: ./src/entity.js\n\n\n\n\n\n\nclass entity_Entity extends AssetOwner {\n\n  constructor(assetPaths, startingXLoc, startingYLoc) {\n    super(assetPaths);\n    this.frameWidth = 60;\n    this.frameHeight = 110;\n    this.location = {\n      x: ((startingXLoc === undefined) ? 0 : startingXLoc),\n      y: ((startingYLoc === undefined) ? 0 : startingYLoc)\n    };\n    this.destination = undefined;\n  }\n\n  get image() {\n    return Assets.get(this.assetPaths[0]);\n  }\n\n  get frameXOrigin() {\n    return 0;\n  }\n\n  get frameYOrigin() {\n    return 0;\n  }\n\n  respondToMouse(event) {\n    this.destination = {x: event.x, y: event.y};\n  }\n\n  tick() {\n    if (this.destination != undefined) {\n      let dx = this.location.x - this.destination.x, dy = this.location.y - this.destination.y;\n      let dist = Math.sqrt(dx*dx+dy*dy);\n\n      let velX = ( dx / dist) * 5;\n      let velY = ( dy / dist ) * 5;\n\n      this.location.x -= velX;\n      this.location.y -= velY;\n    }\n  }\n\n}\n\n// CONCATENATED MODULE: ./src/input.js\n\n\n\nconst Input = (function() {\n\n  let keysDown = [];\n  let keysPressed = [];\n  let mouseEventPoint = undefined;\n\n  function keyDown(keyCode) {\n    if (keysPressed.indexOf(keyCode) < 0) {\n      keysPressed.push(keyCode);\n    }\n    if (keysDown.indexOf(keyCode) < 0) {\n      keysDown.push(keyCode);\n    }\n  }\n\n  function keyUp(keyCode) {\n    keysDown = keysDown.filter( (element) => {\n      return element != keyCode;\n    });\n  }\n\n  function getKeysPressed() {\n    return keysDown.concat(keysPressed.filter( (key) => {\n      return keysDown.indexOf(key) < 0;\n    }));\n  }\n\n  function mouseUp(point) {\n    mouseEventPoint = point;\n  }\n\n  function getMouseEvent() {\n    return mouseEventPoint;\n  }\n\n  function resetInputs() {\n    keysPressed = [];\n    mouseEventPoint = undefined;\n  }\n\n  return {\n    keyDown: keyDown,\n    keyUp: keyUp,\n    getKeysPressed: getKeysPressed,\n    mouseUp: mouseUp,\n    getMouseEvent: getMouseEvent,\n    resetInputs: resetInputs\n  }\n\n})();\n\n// CONCATENATED MODULE: ./src/index.js\n\n\n\n\n\n\n\n\n\n\n\n\ndocument.addEventListener(\"DOMContentLoaded\", function() {\n\n  console.log(\"Proxma Reverie approaches!\");\n\n  var viewport = document.getElementById('viewport-canvas');\n  var viewportContext = viewport.getContext('2d');\n  let viewportWidth = 600, viewportHeight = 400;\n  viewport.width = viewportWidth;\n  viewport.height = viewportHeight;\n\n  let mapSize = 10;\n\n  // let viewOffsetLimitX = (mapSize * tileWidth) - viewportWidth - mapSize;\n  // let viewOffsetLimitY = (mapSize * tileHeight) - viewportHeight - mapSize;\n\n  let tiles = [];\n  for (let tileImagePath of tileImagePaths) {\n    tiles.push(new tile_Tile([tileImagePath]));\n  }\n  let map = new Map(tiles, mapSize);\n  let mobile = new entity_Entity(mobileSpritePaths, viewportWidth / 2, viewportHeight / 2);\n\n  Assets.loadAssets([...tiles, mobile], () => {\n\n    document.getElementById('loading-images-message').classList.add('hide');\n    document.getElementById('images-loaded-message').classList.remove('hide');\n\n    setTimeout(() => {\n\n      let viewOffsetX = ((map.mapCanvas.width) / 2) - (viewportWidth / 2);\n      let viewOffsetY = ((map.mapCanvas.height) / 2) - (viewportHeight / 2);\n\n      doTick(map, viewOffsetX, viewOffsetY);\n    }, 500);\n\n  });\n\n  function doTick(map, viewOffsetX, viewOffsetY) {\n    // console.log('tick');\n    viewportContext.clearRect(0, 0, viewportWidth, viewportHeight);\n    viewportContext.drawImage(map.mapCanvas, viewOffsetX, viewOffsetY, viewportWidth, viewportHeight, 0, 0, viewportWidth, viewportHeight);\n\n    let mouseEvent = Input.getMouseEvent();\n    if (mouseEvent != undefined) {\n\n      console.log(\"\");\n      console.log(`canvas position: ${mouseEvent.x}, ${mouseEvent.y}`);\n      let mapPosition = getCursorMapPosition(viewOffsetX, viewOffsetY, mouseEvent);\n      console.log(`map position: ${mapPosition.x}, ${mapPosition.y}`);\n      let tilePosition = getCursorTilePosition(map, mapPosition);\n      console.log(`tile position: ${tilePosition.x}, ${tilePosition.y}`);\n      console.log(\"\");\n\n      mobile.respondToMouse(mouseEvent);\n    }\n\n    mobile.tick();\n\n    viewportContext.drawImage(\n      mobile.image,\n      mobile.frameXOrigin, mobile.frameYOrigin,\n      mobile.frameWidth, mobile.frameHeight,\n      mobile.location.x, mobile.location.y,\n      mobile.frameWidth, mobile.frameHeight\n    );\n\n    Input.resetInputs();\n\n    setTimeout(() => {\n      doTick(map, viewOffsetX, viewOffsetY);\n    }, 500);\n\n  }\n\n  document.addEventListener('keydown', (event) => {\n    Input.keyDown(event.key);\n  });\n\n  document.addEventListener('keyup', (event) => {\n    Input.keyUp(event.key);\n  });\n\n  viewport.addEventListener('mouseup', (event) => {\n    Input.mouseUp(getCursorCanvasPosition(viewport, event));\n  });\n\n  function getCursorCanvasPosition(canvas, position) {\n    let rect = canvas.getBoundingClientRect();\n    let x = position.clientX - rect.left;\n    let y = position.clientY - rect.top;\n    return { x: x, y: y };\n  }\n\n  function getCursorMapPosition(viewOffsetX, viewOffsetY, position) {\n    let mouseMapX = viewOffsetX + position.x;\n    let mouseMapY = viewOffsetY + position.y;\n    return { x: mouseMapX, y: mouseMapY };\n  }\n\n  function getCursorTilePosition(map, position) {\n    let halfTileWidth = map.tileWidth / 2;\n    let halfTileHeight = map.tileHeight / 2;\n    let halfMapSize = map.mapSize / 2;\n    let tileX = ((position.x / halfTileWidth  + position.y / halfTileHeight) / 2) - halfMapSize;\n    let tileY = ((position.y / halfTileHeight - position.x / halfTileWidth) / 2) + halfMapSize;\n    return { x: Math.floor(tileX), y: Math.floor(tileY) };\n  }\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hc3NldF9tYW5hZ2VyLmpzP2FlMGMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0X293bmVyLmpzPzc0YTIiLCJ3ZWJwYWNrOi8vLy4vc3JjL3RpbGUuanM/MGM4MCIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC5qcz9lMGViIiwid2VicGFjazovLy8uL3NyYy9tYXAuanM/MThiYSIsIndlYnBhY2s6Ly8vLi9zcmMvZW50aXR5LmpzPzYyN2EiLCJ3ZWJwYWNrOi8vLy4vc3JjL2lucHV0LmpzPzllZjgiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzP2I2MzUiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IEFzc2V0cyA9IChmdW5jdGlvbigpIHtcblxuICBsZXQgYXNzZXRzID0ge307XG5cbiAgZnVuY3Rpb24gbG9hZEFzc2V0cyhhc3NldE93bmVycywgY2FsbGJhY2spIHtcbiAgICBsZXQgdGVtcEFzc2V0UGF0aHMgPSBbXVxuICAgIGZvciAobGV0IGFzc2V0T3duZXIgb2YgYXNzZXRPd25lcnMpIHtcbiAgICAgIHRlbXBBc3NldFBhdGhzID0gdGVtcEFzc2V0UGF0aHMuY29uY2F0KGFzc2V0T3duZXIuYXNzZXRQYXRocyk7XG4gICAgfVxuICAgIGxldCBhc3NldFBhdGhzID0gWy4uLiBuZXcgU2V0KHRlbXBBc3NldFBhdGhzKV07XG5cbiAgICBsZXQgYXNzZXRzUmVtYWluaW5nID0gYXNzZXRQYXRocy5sZW5ndGg7XG4gICAgZm9yIChsZXQgYXNzZXRQYXRoIG9mIGFzc2V0UGF0aHMpIHtcblxuICAgICAgbGV0IGFzc2V0ID0gbmV3IEltYWdlKCk7XG4gICAgICBhc3NldC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgYXNzZXRzW2Fzc2V0UGF0aF0gPSBhc3NldDtcbiAgICAgICAgYXNzZXRzUmVtYWluaW5nLS07XG4gICAgICAgIGlmIChhc3NldHNSZW1haW5pbmcgPD0gMCkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBhc3NldC5zcmMgPSBhc3NldFBhdGg7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0KGFzc2V0UGF0aCkge1xuICAgIHJldHVybiBhc3NldHNbYXNzZXRQYXRoXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbG9hZEFzc2V0czogbG9hZEFzc2V0cyxcbiAgICBnZXQ6IGdldFxuICB9XG5cbn0pKCk7XG4iLCJcblwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBc3NldE93bmVyIHtcblxuICBjb25zdHJ1Y3Rvcihhc3NldFBhdGhzKSB7XG4gICAgdGhpcy5hc3NldFBhdGhzID0gYXNzZXRQYXRocztcbiAgfVxuXG59XG4iLCJcblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBBc3NldHMgfSBmcm9tIFwiLi9hc3NldF9tYW5hZ2VyXCI7XG5pbXBvcnQgQXNzZXRPd25lciBmcm9tIFwiLi9hc3NldF9vd25lclwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaWxlIGV4dGVuZHMgQXNzZXRPd25lciB7XG5cbiAgY29uc3RydWN0b3IoYXNzZXRQYXRocykge1xuICAgIHN1cGVyKGFzc2V0UGF0aHMpO1xuICAgIHRoaXMudGlsZVdpZHRoID0gMTI4O1xuICAgIHRoaXMudGlsZUhlaWdodCA9IDY0O1xuICAgIHRoaXMuaW1hZ2VGcmFtZUluZGV4ID0gMDtcbiAgfVxuXG4gIGdldCBpbWcoKSB7XG4gICAgcmV0dXJuIEFzc2V0cy5nZXQodGhpcy5hc3NldFBhdGhzW3RoaXMuaW1hZ2VGcmFtZUluZGV4XSk7XG4gIH1cblxufVxuIiwiXG5cInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IHRpbGVJbWFnZVBhdGhzID0gW1xuICAnLi9zcmMvaW1nL2dyb3VuZF90aWxlcy9icmlja3BhdmVyczIucG5nJyxcbiAgJy4vc3JjL2ltZy9ncm91bmRfdGlsZXMvY29uY3JldGUzNjhhLnBuZycsXG4gICcuL3NyYy9pbWcvZ3JvdW5kX3RpbGVzL2NyZXRlYnJpY2s5NzAucG5nJyxcbiAgJy4vc3JjL2ltZy9ncm91bmRfdGlsZXMvZGlydC5wbmcnLFxuICAnLi9zcmMvaW1nL2dyb3VuZF90aWxlcy9kaXJ0c2FuZDIucG5nJyxcbiAgJy4vc3JjL2ltZy9ncm91bmRfdGlsZXMvcm9jay5wbmcnLFxuICAnLi9zcmMvaW1nL2dyb3VuZF90aWxlcy9zbm93LnBuZycsXG4gICcuL3NyYy9pbWcvZ3JvdW5kX3RpbGVzL3N0b25lLnBuZydcbl07XG5cbmV4cG9ydCBjb25zdCBtb2JpbGVTcHJpdGVQYXRocyA9IFtcbiAgJy4vc3JjL2ltZy9tb2JpbGVzLzh3YXlfbW9iaWxlLnBuZydcbl1cblxuZXhwb3J0IGNvbnN0IHJhbmQgPSAobWF4KSA9PiB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBNYXRoLmZsb29yKG1heCkpO1xufVxuIiwiXG5cInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgcmFuZCB9IGZyb20gXCIuL3V0aWxcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFwIHtcblxuICBjb25zdHJ1Y3Rvcih0aWxlcywgbWFwU2l6ZSkge1xuICAgIHRoaXMudGlsZXMgPSB0aWxlcztcbiAgICB0aGlzLm1hcFNpemUgPSBtYXBTaXplO1xuICAgIHRoaXMudGlsZVdpZHRoID0gdGlsZXNbMF0udGlsZVdpZHRoO1xuICAgIHRoaXMudGlsZUhlaWdodCA9IHRpbGVzWzBdLnRpbGVIZWlnaHQ7XG4gICAgdGhpcy5tYXBEZWYgPSBidWlsZE1hcERlZih0aGlzKTtcbiAgfVxuXG4gIGdldCBtYXBDYW52YXMoKSB7XG4gICAgaWYgKHRoaXMubXlNYXBDYW52YXMgPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm15TWFwQ2FudmFzID0gZHJhd01hcENhbnZhcyh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubXlNYXBDYW52YXM7XG4gIH1cblxufTtcblxuZnVuY3Rpb24gYnVpbGRNYXBEZWYobWFwKSB7XG4gIGxldCBtYXBEZWYgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXAubWFwU2l6ZTsgaSsrKSB7XG4gICAgbWFwRGVmW2ldID0gW107XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXAubWFwU2l6ZTsgaisrKSB7XG4gICAgICBtYXBEZWZbaV1bal0gPSBtYXAudGlsZXNbcmFuZChtYXAudGlsZXMubGVuZ3RoKV07XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXBEZWY7XG59XG5cbmZ1bmN0aW9uIGRyYXdNYXBDYW52YXMobWFwKSB7XG4gIGNvbnNvbGUubG9nKCdib2InKTtcbiAgbGV0IG1hcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIG1hcENhbnZhcy53aWR0aCA9IG1hcC5tYXBTaXplICogbWFwLnRpbGVXaWR0aCAtIG1hcC5tYXBTaXplO1xuICBtYXBDYW52YXMuaGVpZ2h0ID0gbWFwLm1hcFNpemUgKiBtYXAudGlsZUhlaWdodCAtIG1hcC5tYXBTaXplO1xuXG4gIGZvciAobGV0IFt4LCByb3ddIG9mIG1hcC5tYXBEZWYuZW50cmllcygpKSB7XG4gICAgZm9yIChsZXQgW3ksIHRpbGVdIG9mIHJvdy5lbnRyaWVzKCkpIHtcbiAgICAgIGRyYXdUaWxlKG1hcCwgbWFwQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKSwgdGlsZSwgeCwgeSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXBDYW52YXM7XG59XG5cbmZ1bmN0aW9uIGRyYXdUaWxlKG1hcCwgY29udGV4dCwgdGlsZSwgbWFwWCwgbWFwWSkge1xuICBsZXQgeE9mZnNldCA9ICgobWFwLm1hcFNpemUgKiBtYXAudGlsZVdpZHRoKSAvIDIpIC0gKG1hcC50aWxlV2lkdGggLyAyKTtcbiAgbGV0IGNvbnRleHRYID0gKChtYXBYIC0gbWFwWSkgKiAobWFwLnRpbGVXaWR0aCAvIDIpKSAtIG1hcFggKyB4T2Zmc2V0O1xuICBsZXQgY29udGV4dFkgPSAobWFwWCArIG1hcFkpICogKG1hcC50aWxlSGVpZ2h0IC8gMikgLSBtYXBZO1xuICBjb250ZXh0LmRyYXdJbWFnZSh0aWxlLmltZywgY29udGV4dFgsIGNvbnRleHRZLCBtYXAudGlsZVdpZHRoLCBtYXAudGlsZUhlaWdodCk7XG59XG4iLCJcblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBBc3NldHMgfSBmcm9tIFwiLi9hc3NldF9tYW5hZ2VyXCI7XG5pbXBvcnQgQXNzZXRPd25lciBmcm9tIFwiLi9hc3NldF9vd25lclwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbnRpdHkgZXh0ZW5kcyBBc3NldE93bmVyIHtcblxuICBjb25zdHJ1Y3Rvcihhc3NldFBhdGhzLCBzdGFydGluZ1hMb2MsIHN0YXJ0aW5nWUxvYykge1xuICAgIHN1cGVyKGFzc2V0UGF0aHMpO1xuICAgIHRoaXMuZnJhbWVXaWR0aCA9IDYwO1xuICAgIHRoaXMuZnJhbWVIZWlnaHQgPSAxMTA7XG4gICAgdGhpcy5sb2NhdGlvbiA9IHtcbiAgICAgIHg6ICgoc3RhcnRpbmdYTG9jID09PSB1bmRlZmluZWQpID8gMCA6IHN0YXJ0aW5nWExvYyksXG4gICAgICB5OiAoKHN0YXJ0aW5nWUxvYyA9PT0gdW5kZWZpbmVkKSA/IDAgOiBzdGFydGluZ1lMb2MpXG4gICAgfTtcbiAgICB0aGlzLmRlc3RpbmF0aW9uID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZ2V0IGltYWdlKCkge1xuICAgIHJldHVybiBBc3NldHMuZ2V0KHRoaXMuYXNzZXRQYXRoc1swXSk7XG4gIH1cblxuICBnZXQgZnJhbWVYT3JpZ2luKCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZ2V0IGZyYW1lWU9yaWdpbigpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJlc3BvbmRUb01vdXNlKGV2ZW50KSB7XG4gICAgdGhpcy5kZXN0aW5hdGlvbiA9IHt4OiBldmVudC54LCB5OiBldmVudC55fTtcbiAgfVxuXG4gIHRpY2soKSB7XG4gICAgaWYgKHRoaXMuZGVzdGluYXRpb24gIT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgZHggPSB0aGlzLmxvY2F0aW9uLnggLSB0aGlzLmRlc3RpbmF0aW9uLngsIGR5ID0gdGhpcy5sb2NhdGlvbi55IC0gdGhpcy5kZXN0aW5hdGlvbi55O1xuICAgICAgbGV0IGRpc3QgPSBNYXRoLnNxcnQoZHgqZHgrZHkqZHkpO1xuXG4gICAgICBsZXQgdmVsWCA9ICggZHggLyBkaXN0KSAqIDU7XG4gICAgICBsZXQgdmVsWSA9ICggZHkgLyBkaXN0ICkgKiA1O1xuXG4gICAgICB0aGlzLmxvY2F0aW9uLnggLT0gdmVsWDtcbiAgICAgIHRoaXMubG9jYXRpb24ueSAtPSB2ZWxZO1xuICAgIH1cbiAgfVxuXG59XG4iLCJcblwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgSW5wdXQgPSAoZnVuY3Rpb24oKSB7XG5cbiAgbGV0IGtleXNEb3duID0gW107XG4gIGxldCBrZXlzUHJlc3NlZCA9IFtdO1xuICBsZXQgbW91c2VFdmVudFBvaW50ID0gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIGtleURvd24oa2V5Q29kZSkge1xuICAgIGlmIChrZXlzUHJlc3NlZC5pbmRleE9mKGtleUNvZGUpIDwgMCkge1xuICAgICAga2V5c1ByZXNzZWQucHVzaChrZXlDb2RlKTtcbiAgICB9XG4gICAgaWYgKGtleXNEb3duLmluZGV4T2Yoa2V5Q29kZSkgPCAwKSB7XG4gICAgICBrZXlzRG93bi5wdXNoKGtleUNvZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGtleVVwKGtleUNvZGUpIHtcbiAgICBrZXlzRG93biA9IGtleXNEb3duLmZpbHRlciggKGVsZW1lbnQpID0+IHtcbiAgICAgIHJldHVybiBlbGVtZW50ICE9IGtleUNvZGU7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRLZXlzUHJlc3NlZCgpIHtcbiAgICByZXR1cm4ga2V5c0Rvd24uY29uY2F0KGtleXNQcmVzc2VkLmZpbHRlciggKGtleSkgPT4ge1xuICAgICAgcmV0dXJuIGtleXNEb3duLmluZGV4T2Yoa2V5KSA8IDA7XG4gICAgfSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91c2VVcChwb2ludCkge1xuICAgIG1vdXNlRXZlbnRQb2ludCA9IHBvaW50O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TW91c2VFdmVudCgpIHtcbiAgICByZXR1cm4gbW91c2VFdmVudFBvaW50O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRJbnB1dHMoKSB7XG4gICAga2V5c1ByZXNzZWQgPSBbXTtcbiAgICBtb3VzZUV2ZW50UG9pbnQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGtleURvd246IGtleURvd24sXG4gICAga2V5VXA6IGtleVVwLFxuICAgIGdldEtleXNQcmVzc2VkOiBnZXRLZXlzUHJlc3NlZCxcbiAgICBtb3VzZVVwOiBtb3VzZVVwLFxuICAgIGdldE1vdXNlRXZlbnQ6IGdldE1vdXNlRXZlbnQsXG4gICAgcmVzZXRJbnB1dHM6IHJlc2V0SW5wdXRzXG4gIH1cblxufSkoKTtcbiIsIlxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBcIi4vc3R5bGVzL2luZGV4LmNzc1wiO1xuXG5pbXBvcnQgeyBBc3NldHMgfSBmcm9tIFwiLi9hc3NldF9tYW5hZ2VyXCI7XG5pbXBvcnQgVGlsZSBmcm9tIFwiLi90aWxlXCI7XG5pbXBvcnQgTWFwIGZyb20gXCIuL21hcFwiO1xuaW1wb3J0IEVudGl0eSBmcm9tIFwiLi9lbnRpdHlcIjtcbmltcG9ydCB7IHRpbGVJbWFnZVBhdGhzLCBtb2JpbGVTcHJpdGVQYXRocyB9IGZyb20gXCIuL3V0aWxcIjtcbmltcG9ydCB7IElucHV0IH0gZnJvbSBcIi4vaW5wdXRcIjtcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZnVuY3Rpb24oKSB7XG5cbiAgY29uc29sZS5sb2coXCJQcm94bWEgUmV2ZXJpZSBhcHByb2FjaGVzIVwiKTtcblxuICB2YXIgdmlld3BvcnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndmlld3BvcnQtY2FudmFzJyk7XG4gIHZhciB2aWV3cG9ydENvbnRleHQgPSB2aWV3cG9ydC5nZXRDb250ZXh0KCcyZCcpO1xuICBsZXQgdmlld3BvcnRXaWR0aCA9IDYwMCwgdmlld3BvcnRIZWlnaHQgPSA0MDA7XG4gIHZpZXdwb3J0LndpZHRoID0gdmlld3BvcnRXaWR0aDtcbiAgdmlld3BvcnQuaGVpZ2h0ID0gdmlld3BvcnRIZWlnaHQ7XG5cbiAgbGV0IG1hcFNpemUgPSAxMDtcblxuICAvLyBsZXQgdmlld09mZnNldExpbWl0WCA9IChtYXBTaXplICogdGlsZVdpZHRoKSAtIHZpZXdwb3J0V2lkdGggLSBtYXBTaXplO1xuICAvLyBsZXQgdmlld09mZnNldExpbWl0WSA9IChtYXBTaXplICogdGlsZUhlaWdodCkgLSB2aWV3cG9ydEhlaWdodCAtIG1hcFNpemU7XG5cbiAgbGV0IHRpbGVzID0gW107XG4gIGZvciAobGV0IHRpbGVJbWFnZVBhdGggb2YgdGlsZUltYWdlUGF0aHMpIHtcbiAgICB0aWxlcy5wdXNoKG5ldyBUaWxlKFt0aWxlSW1hZ2VQYXRoXSkpO1xuICB9XG4gIGxldCBtYXAgPSBuZXcgTWFwKHRpbGVzLCBtYXBTaXplKTtcbiAgbGV0IG1vYmlsZSA9IG5ldyBFbnRpdHkobW9iaWxlU3ByaXRlUGF0aHMsIHZpZXdwb3J0V2lkdGggLyAyLCB2aWV3cG9ydEhlaWdodCAvIDIpO1xuXG4gIEFzc2V0cy5sb2FkQXNzZXRzKFsuLi50aWxlcywgbW9iaWxlXSwgKCkgPT4ge1xuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvYWRpbmctaW1hZ2VzLW1lc3NhZ2UnKS5jbGFzc0xpc3QuYWRkKCdoaWRlJyk7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ltYWdlcy1sb2FkZWQtbWVzc2FnZScpLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGUnKTtcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuXG4gICAgICBsZXQgdmlld09mZnNldFggPSAoKG1hcC5tYXBDYW52YXMud2lkdGgpIC8gMikgLSAodmlld3BvcnRXaWR0aCAvIDIpO1xuICAgICAgbGV0IHZpZXdPZmZzZXRZID0gKChtYXAubWFwQ2FudmFzLmhlaWdodCkgLyAyKSAtICh2aWV3cG9ydEhlaWdodCAvIDIpO1xuXG4gICAgICBkb1RpY2sobWFwLCB2aWV3T2Zmc2V0WCwgdmlld09mZnNldFkpO1xuICAgIH0sIDUwMCk7XG5cbiAgfSk7XG5cbiAgZnVuY3Rpb24gZG9UaWNrKG1hcCwgdmlld09mZnNldFgsIHZpZXdPZmZzZXRZKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ3RpY2snKTtcbiAgICB2aWV3cG9ydENvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHZpZXdwb3J0V2lkdGgsIHZpZXdwb3J0SGVpZ2h0KTtcbiAgICB2aWV3cG9ydENvbnRleHQuZHJhd0ltYWdlKG1hcC5tYXBDYW52YXMsIHZpZXdPZmZzZXRYLCB2aWV3T2Zmc2V0WSwgdmlld3BvcnRXaWR0aCwgdmlld3BvcnRIZWlnaHQsIDAsIDAsIHZpZXdwb3J0V2lkdGgsIHZpZXdwb3J0SGVpZ2h0KTtcblxuICAgIGxldCBtb3VzZUV2ZW50ID0gSW5wdXQuZ2V0TW91c2VFdmVudCgpO1xuICAgIGlmIChtb3VzZUV2ZW50ICE9IHVuZGVmaW5lZCkge1xuXG4gICAgICBjb25zb2xlLmxvZyhcIlwiKTtcbiAgICAgIGNvbnNvbGUubG9nKGBjYW52YXMgcG9zaXRpb246ICR7bW91c2VFdmVudC54fSwgJHttb3VzZUV2ZW50Lnl9YCk7XG4gICAgICBsZXQgbWFwUG9zaXRpb24gPSBnZXRDdXJzb3JNYXBQb3NpdGlvbih2aWV3T2Zmc2V0WCwgdmlld09mZnNldFksIG1vdXNlRXZlbnQpO1xuICAgICAgY29uc29sZS5sb2coYG1hcCBwb3NpdGlvbjogJHttYXBQb3NpdGlvbi54fSwgJHttYXBQb3NpdGlvbi55fWApO1xuICAgICAgbGV0IHRpbGVQb3NpdGlvbiA9IGdldEN1cnNvclRpbGVQb3NpdGlvbihtYXAsIG1hcFBvc2l0aW9uKTtcbiAgICAgIGNvbnNvbGUubG9nKGB0aWxlIHBvc2l0aW9uOiAke3RpbGVQb3NpdGlvbi54fSwgJHt0aWxlUG9zaXRpb24ueX1gKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiXCIpO1xuXG4gICAgICBtb2JpbGUucmVzcG9uZFRvTW91c2UobW91c2VFdmVudCk7XG4gICAgfVxuXG4gICAgbW9iaWxlLnRpY2soKTtcblxuICAgIHZpZXdwb3J0Q29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICBtb2JpbGUuaW1hZ2UsXG4gICAgICBtb2JpbGUuZnJhbWVYT3JpZ2luLCBtb2JpbGUuZnJhbWVZT3JpZ2luLFxuICAgICAgbW9iaWxlLmZyYW1lV2lkdGgsIG1vYmlsZS5mcmFtZUhlaWdodCxcbiAgICAgIG1vYmlsZS5sb2NhdGlvbi54LCBtb2JpbGUubG9jYXRpb24ueSxcbiAgICAgIG1vYmlsZS5mcmFtZVdpZHRoLCBtb2JpbGUuZnJhbWVIZWlnaHRcbiAgICApO1xuXG4gICAgSW5wdXQucmVzZXRJbnB1dHMoKTtcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZG9UaWNrKG1hcCwgdmlld09mZnNldFgsIHZpZXdPZmZzZXRZKTtcbiAgICB9LCA1MDApO1xuXG4gIH1cblxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGV2ZW50KSA9PiB7XG4gICAgSW5wdXQua2V5RG93bihldmVudC5rZXkpO1xuICB9KTtcblxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIChldmVudCkgPT4ge1xuICAgIElucHV0LmtleVVwKGV2ZW50LmtleSk7XG4gIH0pO1xuXG4gIHZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCAoZXZlbnQpID0+IHtcbiAgICBJbnB1dC5tb3VzZVVwKGdldEN1cnNvckNhbnZhc1Bvc2l0aW9uKHZpZXdwb3J0LCBldmVudCkpO1xuICB9KTtcblxuICBmdW5jdGlvbiBnZXRDdXJzb3JDYW52YXNQb3NpdGlvbihjYW52YXMsIHBvc2l0aW9uKSB7XG4gICAgbGV0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHggPSBwb3NpdGlvbi5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgIGxldCB5ID0gcG9zaXRpb24uY2xpZW50WSAtIHJlY3QudG9wO1xuICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEN1cnNvck1hcFBvc2l0aW9uKHZpZXdPZmZzZXRYLCB2aWV3T2Zmc2V0WSwgcG9zaXRpb24pIHtcbiAgICBsZXQgbW91c2VNYXBYID0gdmlld09mZnNldFggKyBwb3NpdGlvbi54O1xuICAgIGxldCBtb3VzZU1hcFkgPSB2aWV3T2Zmc2V0WSArIHBvc2l0aW9uLnk7XG4gICAgcmV0dXJuIHsgeDogbW91c2VNYXBYLCB5OiBtb3VzZU1hcFkgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEN1cnNvclRpbGVQb3NpdGlvbihtYXAsIHBvc2l0aW9uKSB7XG4gICAgbGV0IGhhbGZUaWxlV2lkdGggPSBtYXAudGlsZVdpZHRoIC8gMjtcbiAgICBsZXQgaGFsZlRpbGVIZWlnaHQgPSBtYXAudGlsZUhlaWdodCAvIDI7XG4gICAgbGV0IGhhbGZNYXBTaXplID0gbWFwLm1hcFNpemUgLyAyO1xuICAgIGxldCB0aWxlWCA9ICgocG9zaXRpb24ueCAvIGhhbGZUaWxlV2lkdGggICsgcG9zaXRpb24ueSAvIGhhbGZUaWxlSGVpZ2h0KSAvIDIpIC0gaGFsZk1hcFNpemU7XG4gICAgbGV0IHRpbGVZID0gKChwb3NpdGlvbi55IC8gaGFsZlRpbGVIZWlnaHQgLSBwb3NpdGlvbi54IC8gaGFsZlRpbGVXaWR0aCkgLyAyKSArIGhhbGZNYXBTaXplO1xuICAgIHJldHVybiB7IHg6IE1hdGguZmxvb3IodGlsZVgpLCB5OiBNYXRoLmZsb29yKHRpbGVZKSB9O1xuICB9XG5cbn0pO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")},,function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zdHlsZXMvaW5kZXguY3NzPzU5ZDAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n")}]);