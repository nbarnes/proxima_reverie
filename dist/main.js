!function(n){var t={};function g(e){if(t[e])return t[e].exports;var I=t[e]={i:e,l:!1,exports:{}};return n[e].call(I.exports,I,I.exports,g),I.l=!0,I.exports}g.m=n,g.c=t,g.d=function(n,t,e){g.o(n,t)||Object.defineProperty(n,t,{configurable:!1,enumerable:!0,get:e})},g.r=function(n){Object.defineProperty(n,"__esModule",{value:!0})},g.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return g.d(t,"a",t),t},g.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},g.p="",g(g.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./src/styles/index.css\nvar styles = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./src/input.js\n\n\nconst Input = (function() {\n  let keysDown = [];\n  let keysPressed = [];\n  let mouseEvent = undefined;\n\n  function keyDown(keyCode) {\n    if (keysPressed.indexOf(keyCode) < 0) {\n      keysPressed.push(keyCode);\n    }\n    if (keysDown.indexOf(keyCode) < 0) {\n      keysDown.push(keyCode);\n    }\n  }\n\n  function keyUp(keyCode) {\n    keysDown = keysDown.filter(element => {\n      return element != keyCode;\n    });\n  }\n\n  function getKeysPressed() {\n    return keysDown.concat(\n      keysPressed.filter(key => {\n        return keysDown.indexOf(key) < 0;\n      })\n    );\n  }\n\n  function mouseUp(event) {\n    mouseEvent = event;\n  }\n\n  function getMouseEvent() {\n    return mouseEvent;\n  }\n\n  function resetInputs() {\n    keysPressed = [];\n    mouseEvent = undefined;\n  }\n\n  return {\n    keyDown: keyDown,\n    keyUp: keyUp,\n    getKeysPressed: getKeysPressed,\n    mouseUp: mouseUp,\n    getMouseEvent: getMouseEvent,\n    resetInputs: resetInputs\n  };\n})();\n\n// CONCATENATED MODULE: ./src/asset_manager.js\n\n\nconst Assets = (function() {\n  let assets = {};\n\n  function loadAssets(assetOwners, callback) {\n    let tempAssetPaths = [];\n    for (let assetOwner of assetOwners) {\n      tempAssetPaths = tempAssetPaths.concat(assetOwner.assetPaths);\n    }\n    let assetPaths = [...new Set(tempAssetPaths)];\n\n    let assetsRemaining = assetPaths.length;\n    for (let assetPath of assetPaths) {\n      let asset = new Image();\n      asset.onload = function() {\n        assets[assetPath] = asset;\n        assetsRemaining--;\n        if (assetsRemaining <= 0) {\n          callback();\n        }\n      };\n      asset.src = assetPath;\n    }\n  }\n\n  function get(assetPath) {\n    return assets[assetPath];\n  }\n\n  return {\n    loadAssets: loadAssets,\n    get: get\n  };\n})();\n\n// CONCATENATED MODULE: ./src/asset_owner.js\n\n\n\nclass AssetOwner {\n\n  constructor(assetPaths) {\n    this.assetPaths = assetPaths;\n  }\n\n}\n\n// CONCATENATED MODULE: ./src/tile.js\n\n\n\n\n\nclass tile_Tile extends AssetOwner {\n  constructor(assetPaths) {\n    super(assetPaths);\n    this.tileWidth = 128;\n    this.tileHeight = 64;\n    this.imageFrameIndex = 0;\n  }\n\n  get img() {\n    return Assets.get(this.assetPaths[this.imageFrameIndex]);\n  }\n}\n\n// CONCATENATED MODULE: ./src/util.js\n\n\nconst rand = max => {\n  return Math.floor(Math.random() * Math.floor(max));\n};\n\nconst coordsEqual = (a, b) => {\n  if (a.x == undefined || b.x == undefined) {\n    console.log('Undefined value in util.coordsEqual');\n    console.log(`a.x: ${a.x} a.y: ${a.y} b.x: ${b.x} b.y: ${b.y}`);\n  }\n  // console.log('');\n  // console.log('in coordsEqual(a, b) =>');\n  // console.log(`a: ${a.constructor.name}`);\n  // console.log(`  x${a.x}, y${a.y}`);\n  // console.log(`a: ${b.constructor.name}`);\n  // console.log(`  x${b.x}, y${b.y}`);\n  // console.log('');\n  return a.x == b.x && a.y == b.y;\n};\n\nconst arrayIncludesCoords = (arr, coord_a) => {\n  return (\n    arr.filter(coord_b => {\n      return coordsEqual(coord_a, coord_b);\n    }).length > 0\n  );\n};\n\nconst entityMapLocationFromCell = (cell, map, frameOffsets) => {\n  // console.log('start entityMapLocationFromCell');\n  // console.log(cell);\n  let mapDestination = map.mapCoordsForCell({ x: cell.x, y: cell.y });\n  let tileOffset = map.tileOffsets;\n  let mapLocation = {\n    x: mapDestination.x + tileOffset.x - frameOffsets.x,\n    y: mapDestination.y + tileOffset.y - frameOffsets.y\n  };\n  // console.log(mapLocation);\n  return mapLocation;\n};\n\nconst Facing = {\n  SOUTHEAST: 7,\n  SOUTHWEST: 1,\n  NORTHWEST: 3,\n  NORTHEAST: 5\n};\n\n// CONCATENATED MODULE: ./src/cell.js\n\n\nclass Cell {\n  constructor(tile, map, coords) {\n    this.tile = tile;\n    this.map = map;\n    this.coords = coords;\n    this.contents = [];\n  }\n\n  get neighbors() {\n    return this.map.neighbors(this.coords);\n  }\n\n  get x() {\n    return this.coords.x;\n  }\n\n  get y() {\n    return this.coords.y;\n  }\n\n  addContents(entity) {\n    this.contents.push(entity);\n  }\n\n  removeContents(entity) {\n    this.contents = this.contents.filter(el => !(el == entity));\n  }\n\n  pathable() {\n    return this.contents.length == 0;\n  }\n}\n\n// CONCATENATED MODULE: ./src/map.js\n\n\n\n\n\nclass Map {\n  constructor(tiles, mapSize) {\n    this.tiles = tiles;\n    this.mapSize = mapSize;\n    this.tileWidth = tiles[0].tileWidth;\n    this.tileHeight = tiles[0].tileHeight;\n    this.cells = buildCells(this);\n  }\n\n  get mapCanvas() {\n    if (this.myMapCanvas == undefined) {\n      this.myMapCanvas = drawMapCanvas(this);\n    }\n    return this.myMapCanvas;\n  }\n\n  mapCoordsForCell(cellCoords) {\n    let xOffset = (this.mapSize * this.tileWidth) / 2 - this.tileWidth / 2;\n    let mapX = (cellCoords.x - cellCoords.y) * (this.tileWidth / 2) + xOffset;\n    let mapY = (cellCoords.x + cellCoords.y) * (this.tileHeight / 2);\n    return { x: mapX, y: mapY };\n  }\n\n  get tileOffsets() {\n    return { x: this.tileWidth / 2, y: this.tileHeight / 2 };\n  }\n\n  cellAt(coords) {\n    return this.cells[coords.x][coords.y];\n  }\n\n  neighbors(coords) {\n    let neighbors = [];\n    if (coords.x < this.mapSize - 1) {\n      neighbors.push(this.cells[coords.x + 1][coords.y]);\n    }\n    if (coords.x > 0) {\n      neighbors.push(this.cells[coords.x - 1][coords.y]);\n    }\n    if (coords.y < this.mapSize - 1) {\n      neighbors.push(this.cells[coords.x][coords.y + 1]);\n    }\n    if (coords.y > 0) {\n      neighbors.push(this.cells[coords.x][coords.y - 1]);\n    }\n    return neighbors;\n  }\n}\n\nfunction buildCells(map) {\n  let cells = [];\n  for (let i = 0; i < map.mapSize; i++) {\n    cells[i] = [];\n    for (let j = 0; j < map.mapSize; j++) {\n      cells[i][j] = new Cell(map.tiles[rand(map.tiles.length)], map, {\n        x: i,\n        y: j\n      });\n    }\n  }\n  return cells;\n}\n\nfunction drawMapCanvas(map) {\n  let mapCanvas = document.createElement('canvas');\n  mapCanvas.width = map.mapSize * map.tileWidth - map.mapSize;\n  mapCanvas.height = map.mapSize * map.tileHeight - map.mapSize;\n\n  for (let [x, row] of map.cells.entries()) {\n    for (let [y, cell] of row.entries()) {\n      drawTile(map, mapCanvas.getContext('2d'), cell.tile, x, y);\n    }\n  }\n  return mapCanvas;\n}\n\nfunction drawTile(map, context, tile, mapX, mapY) {\n  let contextCoords = map.mapCoordsForCell({ x: mapX, y: mapY });\n  context.drawImage(\n    tile.img,\n    contextCoords.x,\n    contextCoords.y,\n    map.tileWidth,\n    map.tileHeight\n  );\n}\n\n// CONCATENATED MODULE: ./src/entity.js\n\n\n\n\n\n\nclass entity_Entity extends AssetOwner {\n  constructor(entityDef, map, brain) {\n    super(entityDef.imagePaths);\n    this.frameSize = entityDef.frameSize;\n    this.frameOffsets = entityDef.frameOffsets || { x: 0, y: 0 };\n    this.map = map;\n    this.currentCell = this.map.cellAt(entityDef.startCell || { x: 0, y: 0 });\n    this.addToCell(this.currentCell);\n    this.myLocation = entityMapLocationFromCell(\n      this.currentCell,\n      this.map,\n      this.frameOffsets\n    );\n    this.cellPath = [];\n    this.brain = brain;\n    this.destination = undefined;\n    this.facing = entityDef.facing;\n  }\n\n  get image() {\n    return Assets.get(this.assetPaths[0]);\n  }\n\n  get location() {\n    // console.log(this.myLocation);\n    return this.myLocation;\n  }\n\n  set location(newLocation) {\n    let newFacing = undefined;\n    if (newLocation != undefined && this.myLocation != undefined) {\n      if (\n        newLocation.x >= this.myLocation.x &&\n        newLocation.y >= this.myLocation.y\n      ) {\n        newFacing = Facing.SOUTHEAST;\n      } else if (\n        newLocation.x >= this.myLocation.x &&\n        newLocation.y <= this.myLocation.y\n      ) {\n        newFacing = Facing.NORTHEAST;\n      } else if (\n        newLocation.x <= this.myLocation.x &&\n        newLocation.y <= this.myLocation.y\n      ) {\n        newFacing = Facing.NORTHWEST;\n      } else if (\n        newLocation.x <= this.myLocation.x &&\n        newLocation.y >= this.myLocation.y\n      ) {\n        newFacing = Facing.SOUTHWEST;\n      } else {\n        newFacing = Facing.NORTHEAST;\n      }\n    }\n    this.facing = newFacing;\n    this.myLocation = newLocation;\n  }\n\n  get frameXOrigin() {\n    if (this.facing != undefined) {\n      return this.facing * this.frameSize.width;\n    }\n    return 0;\n  }\n\n  get frameYOrigin() {\n    return 0;\n  }\n\n  respondToMouse(eventCell, blockingAnimationCallback) {\n    if (this.activity == undefined && this.brain != undefined) {\n      this.activity = this.brain.getActivity(\n        this,\n        eventCell,\n        blockingAnimationCallback\n      );\n    }\n  }\n\n  activityDone() {\n    this.activity = undefined;\n  }\n\n  moveBetweenCells(from, to) {\n    this.removeFromCell(from);\n    this.addToCell(to);\n  }\n\n  addToCell(cell) {\n    cell.addContents(this);\n    this.currentCell = cell;\n  }\n\n  removeFromCell(cell) {\n    cell.removeContents(this);\n    if (coordsEqual(this.currentCell, cell)) {\n      this.currentCell = undefined;\n    }\n  }\n\n  tick() {\n    if (this.activity != undefined) {\n      this.activity();\n    }\n  }\n}\n\n// CONCATENATED MODULE: ./src/binary_heap.js\n// Code for binary heap adapted from\n// http://eloquentjavascript.net/1st_edition/appendix2.html\n// by Marijn Haverbeke\n\n\n\nclass BinaryHeap {\n  constructor(scoreFunction, equalityFunction) {\n    this.scoreFunction = scoreFunction;\n    this.equalityFunction = equalityFunction;\n    this.elements = [];\n  }\n\n  first() {\n    return this.elements[0];\n  }\n\n  push(newElement) {\n    // Add the new element to the end of the array.\n    this.elements.push(newElement);\n    // Allow it to bubble up.\n    this.bubbleUp(this.elements.length - 1);\n  }\n\n  pop() {\n    // Store the first element so we can return it later.\n    let first = this.elements[0];\n    // Get the element at the end of the array.\n    let last = this.elements.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it sink down.\n    if (this.elements.length > 0) {\n      this.elements[0] = last;\n      this.sinkDown(0);\n    }\n    return first;\n  }\n\n  remove(targetElement) {\n    for (let [i, element] of this.elements.entries()) {\n      if (this.equalityFunction(targetElement, element)) {\n        let lastElement = this.elements.pop();\n        if (!(i == length - 1)) {\n          this.elements[i] = lastElement;\n          this.bubbleUp(i);\n          this.sinkDown(i);\n        }\n      }\n    }\n  }\n\n  size() {\n    return this.elements.length;\n  }\n\n  includes(targetElement) {\n    return this.elements.indexOf(targetElement) != -1;\n  }\n\n  bubbleUp(i) {\n    // Fetch the element that has to be moved.\n    let element = this.elements[i],\n      score = this.scoreFunction(element);\n    // When at 0, an element cannot go up any further.\n    while (i > 0) {\n      // Compute the parent element's index, and fetch it.\n      let parentI = Math.floor((i + 1) / 2) - 1,\n        parent = this.elements[parentI];\n      // If the parent has a lesser score, things are in order and we\n      // are done.\n      if (score >= this.scoreFunction(parent)) break;\n      // Otherwise, swap the parent with the current element and\n      // continue.\n      this.elements[parentI] = element;\n      this.elements[i] = parent;\n      i = parentI;\n    }\n  }\n\n  sinkDown(i) {\n    // Look up the target element and its score.\n    var length = this.elements.length,\n      element = this.elements[i],\n      score = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2i = (i + 1) * 2,\n        child1i = child2i - 1;\n      // This is used to store the new position of the element,\n      // if any.\n      var swap = null;\n      // If the first child exists (is inside the array)...\n      if (child1i < length) {\n        // Look it up and compute its score.\n        var child1 = this.elements[child1i],\n          child1Score = this.scoreFunction(child1);\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < score) swap = child1i;\n      }\n      // Do the same checks for the other child.\n      if (child2i < length) {\n        var child2 = this.elements[child2i],\n          child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap == null ? score : child1Score)) swap = child2i;\n      }\n\n      // No need to swap further, we are done.\n      if (swap == null) break;\n\n      // Otherwise, swap and continue.\n      this.elements[i] = this.elements[swap];\n      this.elements[swap] = element;\n      i = swap;\n    }\n  }\n}\n\n// CONCATENATED MODULE: ./src/brain.js\n\n\n\n\n\nclass brain_MobileBrain {\n  getActivity(entity, eventCell, blockingAnimationCallback) {\n    let start = entity.currentCell;\n    let end = eventCell;\n    let path = buildPathAStar(start, end);\n    let destination = undefined;\n    blockingAnimationCallback(true);\n    return () => {\n      if (destination != undefined) {\n        let nextPosition = getNextMapPosition(entity, destination);\n        entity.location = nextPosition;\n        if (coordsEqual(entity.location, destination)) {\n          destination = undefined;\n        }\n      } else if (path.length > 0) {\n        entity.moveBetweenCells(entity.currentCell, path[0]);\n        destination = getDestination(entity, path);\n      } else {\n        entity.activityDone();\n        blockingAnimationCallback(false);\n      }\n    };\n  }\n}\n\nfunction getNextMapPosition(entity, destination) {\n  let currentLoc = { x: entity.location.x, y: entity.location.y };\n  let dx = currentLoc.x - destination.x,\n    dy = currentLoc.y - destination.y;\n  let dist = Math.sqrt(dx * dx + dy * dy);\n  let velX = (dx / dist) * 5;\n  let velY = (dy / dist) * 5;\n  if (Math.abs(dx) < Math.abs(velX)) {\n    velX = dx;\n  }\n  if (Math.abs(dy) < Math.abs(velY)) {\n    velY = dy;\n  }\n  return {\n    x: (currentLoc.x -= velX),\n    y: (currentLoc.y -= velY)\n  };\n}\n\nfunction getDestination(entity, cellPath) {\n  let nextCellDestination = cellPath.shift();\n  let nextDestination = undefined;\n  if (nextCellDestination != undefined) {\n    nextDestination = entityMapLocationFromCell(\n      nextCellDestination,\n      entity.map,\n      entity.frameOffsets\n    );\n  }\n  return nextDestination;\n}\n\n// Uses Brensenham's line algorithm\nfunction buildPath(start, end) {\n  let path = [];\n\n  let currentX = start.x,\n    currentY = start.y;\n  let deltaX = Math.abs(end.x - start.x),\n    deltaY = Math.abs(end.y - start.y);\n  let slopeX = start.x < end.x ? 1 : -1,\n    slopeY = start.y < end.y ? 1 : -1;\n  let err = deltaX - deltaY;\n\n  while (currentX != end.x || currentY != end.y) {\n    let err2 = 2 * err;\n    if (err2 > deltaY * -1) {\n      err -= deltaY;\n      currentX += slopeX;\n    } else if (err2 < deltaX) {\n      err += deltaX;\n      currentY += slopeY;\n    }\n    path.push({ x: currentX, y: currentY });\n  }\n  return path;\n}\n\nfunction buildPathAStar(start, end) {\n  let open = new BinaryHeap(\n    a => {\n      return a.f;\n    },\n    (a, b) => {\n      return coordsEqual(a, b);\n    }\n  );\n  open.push(new GraphNode(start));\n  let closed = [];\n  while (open.size() > 0) {\n    let currentNode = open.pop();\n    closed.push(currentNode);\n    if (coordsEqual(currentNode, end)) {\n      return buildPath(currentNode);\n    }\n    let neighbors = currentNode.neighbors;\n    for (let neighbor of neighbors) {\n      if (neighbor.pathable()) {\n        let g = currentNode.g + 1;\n        let f = g + manhattenDistance(neighbor, end);\n        if (!arrayIncludesCoords(closed, neighbor)) {\n          if (!open.includes(neighbor)) {\n            neighbor.parent = currentNode;\n            neighbor.f = f;\n            open.push(neighbor);\n          }\n        } else if (neighbor.g >= g) {\n          closed = closed.filter(el => !coordsEqual(el, neighbor));\n          neighbor.parent = currentNode;\n          neighbor.f = f;\n          open.push(nieghbor);\n        }\n      } else if (!arrayIncludesCoords(closed, neighbor)) {\n        closed.push(neighbor);\n      }\n    }\n  }\n  return []; // no path found\n}\n\nfunction buildPath(endNode) {\n  let path = [];\n  while (endNode.parent) {\n    path.push(endNode.cell);\n    endNode = endNode.parent;\n  }\n  return path.reverse();\n}\n\nfunction manhattenDistance(start, end) {\n  return Math.abs(start.x - end.x) + Math.abs(start.y - end.y);\n}\n\nclass GraphNode {\n  constructor(cell) {\n    this.cell = cell;\n    this.f = 0;\n  }\n  get neighbors() {\n    if (this.myNeighbors == undefined) {\n      return this.cell.neighbors.map(neighbor => {\n        return new GraphNode(neighbor);\n      });\n    }\n    return this.myNeighbors;\n  }\n  set g(newG) {\n    /* no op, g is computed from parent.g */\n  }\n  get g() {\n    return this.parent != undefined ? this.parent.g + 1 : 0;\n  }\n  get coords() {\n    return this.cell.coords;\n  }\n  get x() {\n    return this.cell.coords.x;\n  }\n  get y() {\n    return this.cell.coords.y;\n  }\n  pathable() {\n    return this.cell.pathable();\n  }\n}\n\n// CONCATENATED MODULE: ./src/scene.js\n\n\n\n\n\n\n\n\n\nclass scene_Scene {\n  constructor(sceneDef, viewport, viewportDimensions, loadCompleteCallback) {\n    let tiles = sceneDef.mapDef.tileImagePaths.map(tileImagePath => {\n      return new tile_Tile([tileImagePath]);\n    });\n\n    this.map = new Map(tiles, sceneDef.mapDef.mapSize);\n\n    this.mobiles = sceneDef.mobileDefs.map(mobileDef => {\n      return new entity_Entity(mobileDef, this.map, new brain_MobileBrain());\n    });\n    this.activeMobile = this.mobiles[0];\n    this.props = sceneDef.propDefs.map(propDef => {\n      return new entity_Entity(propDef, this.map);\n    });\n\n    this.viewport = viewport;\n    this.viewportDimensions = viewportDimensions;\n\n    Assets.loadAssets([...tiles, ...this.mobiles, ...this.props], () => {\n      this.viewportOffsetDimensions = {\n        x: this.map.mapCanvas.width / 2 - viewportDimensions.x / 2,\n        y: this.map.mapCanvas.height / 2 - viewportDimensions.y / 2\n      };\n      loadCompleteCallback();\n    });\n\n    this.waitingOnAnimation = false;\n  }\n\n  tick() {\n    let mouseEvent = Input.getMouseEvent();\n    if (mouseEvent != undefined) {\n      let eventViewportPosition = getEventViewportPosition(\n        this.viewport,\n        mouseEvent\n      );\n      let eventMapPosition = getCursorMapPosition(\n        this.viewportOffsetDimensions,\n        eventViewportPosition\n      );\n      let cellPosition = getCursorCellPosition(this.map, eventMapPosition);\n\n      if (!this.waitingOnAnimation) {\n        this.activeMobile.respondToMouse(\n          this.map.cellAt(cellPosition),\n          shouldWait => {\n            this.waitingOnAnimation = shouldWait;\n          }\n        );\n\n        if (this.mobiles.slice(-1)[0] == this.activeMobile) {\n          this.activeMobile = this.mobiles[0];\n        } else {\n          this.activeMobile = this.mobiles[\n            this.mobiles.indexOf(this.activeMobile) + 1\n          ];\n        }\n      }\n    }\n\n    this.mobiles.forEach(mobile => {\n      mobile.tick();\n    });\n    this.props.forEach(prop => {\n      prop.tick();\n    });\n\n    let context = this.viewport.getContext('2d');\n    context.clearRect(\n      0,\n      0,\n      this.viewportDimensions.x,\n      this.viewportDimensions.y\n    );\n    context.drawImage(\n      this.map.mapCanvas,\n      this.viewportOffsetDimensions.x,\n      this.viewportOffsetDimensions.y,\n      this.viewportDimensions.x,\n      this.viewportDimensions.y,\n      0,\n      0,\n      this.viewportDimensions.x,\n      this.viewportDimensions.y\n    );\n\n    this.mobiles.forEach(mobile => {\n      context.drawImage(\n        mobile.image,\n        mobile.frameXOrigin,\n        mobile.frameYOrigin,\n        mobile.frameSize.width,\n        mobile.frameSize.height,\n        mobile.location.x - this.viewportOffsetDimensions.x,\n        mobile.location.y - this.viewportOffsetDimensions.y,\n        mobile.frameSize.width,\n        mobile.frameSize.height\n      );\n    });\n\n    this.props.forEach(prop => {\n      context.drawImage(\n        prop.image,\n        prop.frameXOrigin,\n        prop.frameYOrigin,\n        prop.frameSize.width,\n        prop.frameSize.height,\n        prop.location.x - this.viewportOffsetDimensions.x,\n        prop.location.y - this.viewportOffsetDimensions.y,\n        prop.frameSize.width,\n        prop.frameSize.height\n      );\n    });\n\n    Input.resetInputs();\n  }\n}\n\nfunction getCursorMapPosition(viewOffsets, position) {\n  return { x: viewOffsets.x + position.x, y: viewOffsets.y + position.y };\n}\n\nfunction getCursorCellPosition(map, position) {\n  let halfTileWidth = map.tileWidth / 2;\n  let halfTileHeight = map.tileHeight / 2;\n  let halfMapSize = map.mapSize / 2;\n  let cellX =\n    (position.x / halfTileWidth + position.y / halfTileHeight) / 2 -\n    halfMapSize;\n  let cellY =\n    (position.y / halfTileHeight - position.x / halfTileWidth) / 2 +\n    halfMapSize;\n  return { x: Math.floor(cellX), y: Math.floor(cellY) };\n}\n\nfunction getEventViewportPosition(viewport, event) {\n  let rect = viewport.getBoundingClientRect();\n  let x = event.clientX - rect.left;\n  let y = event.clientY - rect.top;\n  return { x: x, y: y };\n}\n\n// CONCATENATED MODULE: ./src/scene_definition.js\n\n\nconst scene_definition_sceneDef = {\n  mapDef: {\n    mapSize: 10,\n    tileImagePaths: [\n      './src/img/ground_tiles/brickpavers2.png',\n      './src/img/ground_tiles/concrete368a.png',\n      './src/img/ground_tiles/cretebrick970.png',\n      './src/img/ground_tiles/dirt.png',\n      './src/img/ground_tiles/dirtsand2.png',\n      './src/img/ground_tiles/rock.png',\n      './src/img/ground_tiles/snow.png',\n      './src/img/ground_tiles/stone.png'\n    ]\n  },\n  mobileDefs: [\n    {\n      imagePaths: ['./src/img/mobiles/8way_mobile.png'],\n      startCell: { x: 3, y: 3 },\n      frameSize: { width: 60, height: 110 },\n      frameOffsets: { x: 30, y: 100 }\n    },\n    {\n      imagePaths: ['./src/img/mobiles/8way_mobile.png'],\n      startCell: { x: 5, y: 4 },\n      frameSize: { width: 60, height: 110 },\n      frameOffsets: { x: 30, y: 100 }\n    },\n    {\n      imagePaths: ['./src/img/mobiles/8way_mobile.png'],\n      startCell: { x: 3, y: 6 },\n      frameSize: { width: 60, height: 110 },\n      frameOffsets: { x: 30, y: 100 }\n    }\n  ],\n  propDefs: [\n    {\n      imagePaths: ['./src/img/props/statue1-01.png'],\n      startCell: { x: 5, y: 5 },\n      frameSize: { width: 128, height: 128 },\n      frameOffsets: { x: 64, y: 112 }\n    },\n    {\n      imagePaths: ['./src/img/props/statue1-02.png'],\n      startCell: { x: 0, y: 3 },\n      frameSize: { width: 128, height: 128 },\n      frameOffsets: { x: 64, y: 112 }\n    },\n    {\n      imagePaths: ['./src/img/props/statue1-03.png'],\n      startCell: { x: 4, y: 1 },\n      frameSize: { width: 128, height: 128 },\n      frameOffsets: { x: 64, y: 112 }\n    },\n    {\n      imagePaths: ['./src/img/props/statue1-04.png'],\n      startCell: { x: 5, y: 1 },\n      frameSize: { width: 128, height: 128 },\n      frameOffsets: { x: 64, y: 112 }\n    },\n    {\n      imagePaths: ['./src/img/props/statue1-02.png'],\n      startCell: { x: 6, y: 0 },\n      frameSize: { width: 128, height: 128 },\n      frameOffsets: { x: 64, y: 112 }\n    },\n    {\n      imagePaths: ['./src/img/props/statue1-03.png'],\n      startCell: { x: 7, y: 9 },\n      frameSize: { width: 128, height: 128 },\n      frameOffsets: { x: 64, y: 112 }\n    }\n  ]\n};\n\n// CONCATENATED MODULE: ./src/index.js\n\n\n\n\n\n\n\n\n\ndocument.addEventListener('DOMContentLoaded', function() {\n  console.log('Proxma Reverie approaches!');\n\n  // console.log('testing BinaryHeap');\n  // let heap = new BinaryHeap(\n  //   el => {\n  //     return el;\n  //   },\n  //   (a, b) => {\n  //     return a == b;\n  //   }\n  // );\n  // for (let entry of [10, 3, 4, 8, 2, 9, 7, 1, 2, 6, 5]) {\n  //   heap.push(entry);\n  // }\n  // heap.remove(2);\n  // while (heap.size() > 0) {\n  //   console.log(heap.pop());\n  // }\n\n  let tickLength = 50;\n\n  var viewport = document.getElementById('viewport-canvas');\n  let viewportDimensions = { x: 600, y: 400 };\n  viewport.width = viewportDimensions.x;\n  viewport.height = viewportDimensions.y;\n\n  let scene = new scene_Scene(scene_definition_sceneDef, viewport, viewportDimensions, () => {\n    setTimeout(() => {\n      tick();\n    }, 0);\n  });\n\n  function tick() {\n    scene.tick();\n    setTimeout(() => {\n      tick();\n    }, tickLength);\n  }\n\n  document.addEventListener('keydown', event => {\n    Input.keyDown(event.key);\n  });\n\n  document.addEventListener('keyup', event => {\n    Input.keyUp(event.key);\n  });\n\n  viewport.addEventListener('mouseup', event => {\n    Input.mouseUp(event);\n  });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9pbnB1dC5qcz85ZWY4Iiwid2VicGFjazovLy8uL3NyYy9hc3NldF9tYW5hZ2VyLmpzP2FlMGMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0X293bmVyLmpzPzc0YTIiLCJ3ZWJwYWNrOi8vLy4vc3JjL3RpbGUuanM/MGM4MCIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC5qcz9lMGViIiwid2VicGFjazovLy8uL3NyYy9jZWxsLmpzPzI0MDQiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hcC5qcz8xOGJhIiwid2VicGFjazovLy8uL3NyYy9lbnRpdHkuanM/NjI3YSIsIndlYnBhY2s6Ly8vLi9zcmMvYmluYXJ5X2hlYXAuanM/YmQyMSIsIndlYnBhY2s6Ly8vLi9zcmMvYnJhaW4uanM/M2JjMyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NlbmUuanM/MjY0YyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NlbmVfZGVmaW5pdGlvbi5qcz80YjhmIiwid2VicGFjazovLy8uL3NyYy9pbmRleC5qcz9iNjM1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGNvbnN0IElucHV0ID0gKGZ1bmN0aW9uKCkge1xuICBsZXQga2V5c0Rvd24gPSBbXTtcbiAgbGV0IGtleXNQcmVzc2VkID0gW107XG4gIGxldCBtb3VzZUV2ZW50ID0gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIGtleURvd24oa2V5Q29kZSkge1xuICAgIGlmIChrZXlzUHJlc3NlZC5pbmRleE9mKGtleUNvZGUpIDwgMCkge1xuICAgICAga2V5c1ByZXNzZWQucHVzaChrZXlDb2RlKTtcbiAgICB9XG4gICAgaWYgKGtleXNEb3duLmluZGV4T2Yoa2V5Q29kZSkgPCAwKSB7XG4gICAgICBrZXlzRG93bi5wdXNoKGtleUNvZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGtleVVwKGtleUNvZGUpIHtcbiAgICBrZXlzRG93biA9IGtleXNEb3duLmZpbHRlcihlbGVtZW50ID0+IHtcbiAgICAgIHJldHVybiBlbGVtZW50ICE9IGtleUNvZGU7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRLZXlzUHJlc3NlZCgpIHtcbiAgICByZXR1cm4ga2V5c0Rvd24uY29uY2F0KFxuICAgICAga2V5c1ByZXNzZWQuZmlsdGVyKGtleSA9PiB7XG4gICAgICAgIHJldHVybiBrZXlzRG93bi5pbmRleE9mKGtleSkgPCAwO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91c2VVcChldmVudCkge1xuICAgIG1vdXNlRXZlbnQgPSBldmVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1vdXNlRXZlbnQoKSB7XG4gICAgcmV0dXJuIG1vdXNlRXZlbnQ7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldElucHV0cygpIHtcbiAgICBrZXlzUHJlc3NlZCA9IFtdO1xuICAgIG1vdXNlRXZlbnQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGtleURvd246IGtleURvd24sXG4gICAga2V5VXA6IGtleVVwLFxuICAgIGdldEtleXNQcmVzc2VkOiBnZXRLZXlzUHJlc3NlZCxcbiAgICBtb3VzZVVwOiBtb3VzZVVwLFxuICAgIGdldE1vdXNlRXZlbnQ6IGdldE1vdXNlRXZlbnQsXG4gICAgcmVzZXRJbnB1dHM6IHJlc2V0SW5wdXRzXG4gIH07XG59KSgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgY29uc3QgQXNzZXRzID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgYXNzZXRzID0ge307XG5cbiAgZnVuY3Rpb24gbG9hZEFzc2V0cyhhc3NldE93bmVycywgY2FsbGJhY2spIHtcbiAgICBsZXQgdGVtcEFzc2V0UGF0aHMgPSBbXTtcbiAgICBmb3IgKGxldCBhc3NldE93bmVyIG9mIGFzc2V0T3duZXJzKSB7XG4gICAgICB0ZW1wQXNzZXRQYXRocyA9IHRlbXBBc3NldFBhdGhzLmNvbmNhdChhc3NldE93bmVyLmFzc2V0UGF0aHMpO1xuICAgIH1cbiAgICBsZXQgYXNzZXRQYXRocyA9IFsuLi5uZXcgU2V0KHRlbXBBc3NldFBhdGhzKV07XG5cbiAgICBsZXQgYXNzZXRzUmVtYWluaW5nID0gYXNzZXRQYXRocy5sZW5ndGg7XG4gICAgZm9yIChsZXQgYXNzZXRQYXRoIG9mIGFzc2V0UGF0aHMpIHtcbiAgICAgIGxldCBhc3NldCA9IG5ldyBJbWFnZSgpO1xuICAgICAgYXNzZXQub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGFzc2V0c1thc3NldFBhdGhdID0gYXNzZXQ7XG4gICAgICAgIGFzc2V0c1JlbWFpbmluZy0tO1xuICAgICAgICBpZiAoYXNzZXRzUmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgYXNzZXQuc3JjID0gYXNzZXRQYXRoO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldChhc3NldFBhdGgpIHtcbiAgICByZXR1cm4gYXNzZXRzW2Fzc2V0UGF0aF07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxvYWRBc3NldHM6IGxvYWRBc3NldHMsXG4gICAgZ2V0OiBnZXRcbiAgfTtcbn0pKCk7XG4iLCJcblwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBc3NldE93bmVyIHtcblxuICBjb25zdHJ1Y3Rvcihhc3NldFBhdGhzKSB7XG4gICAgdGhpcy5hc3NldFBhdGhzID0gYXNzZXRQYXRocztcbiAgfVxuXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IEFzc2V0cyB9IGZyb20gJy4vYXNzZXRfbWFuYWdlcic7XG5pbXBvcnQgQXNzZXRPd25lciBmcm9tICcuL2Fzc2V0X293bmVyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGlsZSBleHRlbmRzIEFzc2V0T3duZXIge1xuICBjb25zdHJ1Y3Rvcihhc3NldFBhdGhzKSB7XG4gICAgc3VwZXIoYXNzZXRQYXRocyk7XG4gICAgdGhpcy50aWxlV2lkdGggPSAxMjg7XG4gICAgdGhpcy50aWxlSGVpZ2h0ID0gNjQ7XG4gICAgdGhpcy5pbWFnZUZyYW1lSW5kZXggPSAwO1xuICB9XG5cbiAgZ2V0IGltZygpIHtcbiAgICByZXR1cm4gQXNzZXRzLmdldCh0aGlzLmFzc2V0UGF0aHNbdGhpcy5pbWFnZUZyYW1lSW5kZXhdKTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgY29uc3QgcmFuZCA9IG1heCA9PiB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBNYXRoLmZsb29yKG1heCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvb3Jkc0VxdWFsID0gKGEsIGIpID0+IHtcbiAgaWYgKGEueCA9PSB1bmRlZmluZWQgfHwgYi54ID09IHVuZGVmaW5lZCkge1xuICAgIGNvbnNvbGUubG9nKCdVbmRlZmluZWQgdmFsdWUgaW4gdXRpbC5jb29yZHNFcXVhbCcpO1xuICAgIGNvbnNvbGUubG9nKGBhLng6ICR7YS54fSBhLnk6ICR7YS55fSBiLng6ICR7Yi54fSBiLnk6ICR7Yi55fWApO1xuICB9XG4gIC8vIGNvbnNvbGUubG9nKCcnKTtcbiAgLy8gY29uc29sZS5sb2coJ2luIGNvb3Jkc0VxdWFsKGEsIGIpID0+Jyk7XG4gIC8vIGNvbnNvbGUubG9nKGBhOiAke2EuY29uc3RydWN0b3IubmFtZX1gKTtcbiAgLy8gY29uc29sZS5sb2coYCAgeCR7YS54fSwgeSR7YS55fWApO1xuICAvLyBjb25zb2xlLmxvZyhgYTogJHtiLmNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gIC8vIGNvbnNvbGUubG9nKGAgIHgke2IueH0sIHkke2IueX1gKTtcbiAgLy8gY29uc29sZS5sb2coJycpO1xuICByZXR1cm4gYS54ID09IGIueCAmJiBhLnkgPT0gYi55O1xufTtcblxuZXhwb3J0IGNvbnN0IGFycmF5SW5jbHVkZXNDb29yZHMgPSAoYXJyLCBjb29yZF9hKSA9PiB7XG4gIHJldHVybiAoXG4gICAgYXJyLmZpbHRlcihjb29yZF9iID0+IHtcbiAgICAgIHJldHVybiBjb29yZHNFcXVhbChjb29yZF9hLCBjb29yZF9iKTtcbiAgICB9KS5sZW5ndGggPiAwXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgZW50aXR5TWFwTG9jYXRpb25Gcm9tQ2VsbCA9IChjZWxsLCBtYXAsIGZyYW1lT2Zmc2V0cykgPT4ge1xuICAvLyBjb25zb2xlLmxvZygnc3RhcnQgZW50aXR5TWFwTG9jYXRpb25Gcm9tQ2VsbCcpO1xuICAvLyBjb25zb2xlLmxvZyhjZWxsKTtcbiAgbGV0IG1hcERlc3RpbmF0aW9uID0gbWFwLm1hcENvb3Jkc0ZvckNlbGwoeyB4OiBjZWxsLngsIHk6IGNlbGwueSB9KTtcbiAgbGV0IHRpbGVPZmZzZXQgPSBtYXAudGlsZU9mZnNldHM7XG4gIGxldCBtYXBMb2NhdGlvbiA9IHtcbiAgICB4OiBtYXBEZXN0aW5hdGlvbi54ICsgdGlsZU9mZnNldC54IC0gZnJhbWVPZmZzZXRzLngsXG4gICAgeTogbWFwRGVzdGluYXRpb24ueSArIHRpbGVPZmZzZXQueSAtIGZyYW1lT2Zmc2V0cy55XG4gIH07XG4gIC8vIGNvbnNvbGUubG9nKG1hcExvY2F0aW9uKTtcbiAgcmV0dXJuIG1hcExvY2F0aW9uO1xufTtcblxuZXhwb3J0IGNvbnN0IEZhY2luZyA9IHtcbiAgU09VVEhFQVNUOiA3LFxuICBTT1VUSFdFU1Q6IDEsXG4gIE5PUlRIV0VTVDogMyxcbiAgTk9SVEhFQVNUOiA1XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDZWxsIHtcbiAgY29uc3RydWN0b3IodGlsZSwgbWFwLCBjb29yZHMpIHtcbiAgICB0aGlzLnRpbGUgPSB0aWxlO1xuICAgIHRoaXMubWFwID0gbWFwO1xuICAgIHRoaXMuY29vcmRzID0gY29vcmRzO1xuICAgIHRoaXMuY29udGVudHMgPSBbXTtcbiAgfVxuXG4gIGdldCBuZWlnaGJvcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLm5laWdoYm9ycyh0aGlzLmNvb3Jkcyk7XG4gIH1cblxuICBnZXQgeCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb29yZHMueDtcbiAgfVxuXG4gIGdldCB5KCkge1xuICAgIHJldHVybiB0aGlzLmNvb3Jkcy55O1xuICB9XG5cbiAgYWRkQ29udGVudHMoZW50aXR5KSB7XG4gICAgdGhpcy5jb250ZW50cy5wdXNoKGVudGl0eSk7XG4gIH1cblxuICByZW1vdmVDb250ZW50cyhlbnRpdHkpIHtcbiAgICB0aGlzLmNvbnRlbnRzID0gdGhpcy5jb250ZW50cy5maWx0ZXIoZWwgPT4gIShlbCA9PSBlbnRpdHkpKTtcbiAgfVxuXG4gIHBhdGhhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRzLmxlbmd0aCA9PSAwO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IHJhbmQgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IENlbGwgZnJvbSAnLi9jZWxsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFwIHtcbiAgY29uc3RydWN0b3IodGlsZXMsIG1hcFNpemUpIHtcbiAgICB0aGlzLnRpbGVzID0gdGlsZXM7XG4gICAgdGhpcy5tYXBTaXplID0gbWFwU2l6ZTtcbiAgICB0aGlzLnRpbGVXaWR0aCA9IHRpbGVzWzBdLnRpbGVXaWR0aDtcbiAgICB0aGlzLnRpbGVIZWlnaHQgPSB0aWxlc1swXS50aWxlSGVpZ2h0O1xuICAgIHRoaXMuY2VsbHMgPSBidWlsZENlbGxzKHRoaXMpO1xuICB9XG5cbiAgZ2V0IG1hcENhbnZhcygpIHtcbiAgICBpZiAodGhpcy5teU1hcENhbnZhcyA9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubXlNYXBDYW52YXMgPSBkcmF3TWFwQ2FudmFzKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5teU1hcENhbnZhcztcbiAgfVxuXG4gIG1hcENvb3Jkc0ZvckNlbGwoY2VsbENvb3Jkcykge1xuICAgIGxldCB4T2Zmc2V0ID0gKHRoaXMubWFwU2l6ZSAqIHRoaXMudGlsZVdpZHRoKSAvIDIgLSB0aGlzLnRpbGVXaWR0aCAvIDI7XG4gICAgbGV0IG1hcFggPSAoY2VsbENvb3Jkcy54IC0gY2VsbENvb3Jkcy55KSAqICh0aGlzLnRpbGVXaWR0aCAvIDIpICsgeE9mZnNldDtcbiAgICBsZXQgbWFwWSA9IChjZWxsQ29vcmRzLnggKyBjZWxsQ29vcmRzLnkpICogKHRoaXMudGlsZUhlaWdodCAvIDIpO1xuICAgIHJldHVybiB7IHg6IG1hcFgsIHk6IG1hcFkgfTtcbiAgfVxuXG4gIGdldCB0aWxlT2Zmc2V0cygpIHtcbiAgICByZXR1cm4geyB4OiB0aGlzLnRpbGVXaWR0aCAvIDIsIHk6IHRoaXMudGlsZUhlaWdodCAvIDIgfTtcbiAgfVxuXG4gIGNlbGxBdChjb29yZHMpIHtcbiAgICByZXR1cm4gdGhpcy5jZWxsc1tjb29yZHMueF1bY29vcmRzLnldO1xuICB9XG5cbiAgbmVpZ2hib3JzKGNvb3Jkcykge1xuICAgIGxldCBuZWlnaGJvcnMgPSBbXTtcbiAgICBpZiAoY29vcmRzLnggPCB0aGlzLm1hcFNpemUgLSAxKSB7XG4gICAgICBuZWlnaGJvcnMucHVzaCh0aGlzLmNlbGxzW2Nvb3Jkcy54ICsgMV1bY29vcmRzLnldKTtcbiAgICB9XG4gICAgaWYgKGNvb3Jkcy54ID4gMCkge1xuICAgICAgbmVpZ2hib3JzLnB1c2godGhpcy5jZWxsc1tjb29yZHMueCAtIDFdW2Nvb3Jkcy55XSk7XG4gICAgfVxuICAgIGlmIChjb29yZHMueSA8IHRoaXMubWFwU2l6ZSAtIDEpIHtcbiAgICAgIG5laWdoYm9ycy5wdXNoKHRoaXMuY2VsbHNbY29vcmRzLnhdW2Nvb3Jkcy55ICsgMV0pO1xuICAgIH1cbiAgICBpZiAoY29vcmRzLnkgPiAwKSB7XG4gICAgICBuZWlnaGJvcnMucHVzaCh0aGlzLmNlbGxzW2Nvb3Jkcy54XVtjb29yZHMueSAtIDFdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5laWdoYm9ycztcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZENlbGxzKG1hcCkge1xuICBsZXQgY2VsbHMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXAubWFwU2l6ZTsgaSsrKSB7XG4gICAgY2VsbHNbaV0gPSBbXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hcC5tYXBTaXplOyBqKyspIHtcbiAgICAgIGNlbGxzW2ldW2pdID0gbmV3IENlbGwobWFwLnRpbGVzW3JhbmQobWFwLnRpbGVzLmxlbmd0aCldLCBtYXAsIHtcbiAgICAgICAgeDogaSxcbiAgICAgICAgeTogalxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjZWxscztcbn1cblxuZnVuY3Rpb24gZHJhd01hcENhbnZhcyhtYXApIHtcbiAgbGV0IG1hcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICBtYXBDYW52YXMud2lkdGggPSBtYXAubWFwU2l6ZSAqIG1hcC50aWxlV2lkdGggLSBtYXAubWFwU2l6ZTtcbiAgbWFwQ2FudmFzLmhlaWdodCA9IG1hcC5tYXBTaXplICogbWFwLnRpbGVIZWlnaHQgLSBtYXAubWFwU2l6ZTtcblxuICBmb3IgKGxldCBbeCwgcm93XSBvZiBtYXAuY2VsbHMuZW50cmllcygpKSB7XG4gICAgZm9yIChsZXQgW3ksIGNlbGxdIG9mIHJvdy5lbnRyaWVzKCkpIHtcbiAgICAgIGRyYXdUaWxlKG1hcCwgbWFwQ2FudmFzLmdldENvbnRleHQoJzJkJyksIGNlbGwudGlsZSwgeCwgeSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXBDYW52YXM7XG59XG5cbmZ1bmN0aW9uIGRyYXdUaWxlKG1hcCwgY29udGV4dCwgdGlsZSwgbWFwWCwgbWFwWSkge1xuICBsZXQgY29udGV4dENvb3JkcyA9IG1hcC5tYXBDb29yZHNGb3JDZWxsKHsgeDogbWFwWCwgeTogbWFwWSB9KTtcbiAgY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgdGlsZS5pbWcsXG4gICAgY29udGV4dENvb3Jkcy54LFxuICAgIGNvbnRleHRDb29yZHMueSxcbiAgICBtYXAudGlsZVdpZHRoLFxuICAgIG1hcC50aWxlSGVpZ2h0XG4gICk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IEFzc2V0cyB9IGZyb20gJy4vYXNzZXRfbWFuYWdlcic7XG5pbXBvcnQgQXNzZXRPd25lciBmcm9tICcuL2Fzc2V0X293bmVyJztcbmltcG9ydCB7IGVudGl0eU1hcExvY2F0aW9uRnJvbUNlbGwsIEZhY2luZywgY29vcmRzRXF1YWwgfSBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbnRpdHkgZXh0ZW5kcyBBc3NldE93bmVyIHtcbiAgY29uc3RydWN0b3IoZW50aXR5RGVmLCBtYXAsIGJyYWluKSB7XG4gICAgc3VwZXIoZW50aXR5RGVmLmltYWdlUGF0aHMpO1xuICAgIHRoaXMuZnJhbWVTaXplID0gZW50aXR5RGVmLmZyYW1lU2l6ZTtcbiAgICB0aGlzLmZyYW1lT2Zmc2V0cyA9IGVudGl0eURlZi5mcmFtZU9mZnNldHMgfHwgeyB4OiAwLCB5OiAwIH07XG4gICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgdGhpcy5jdXJyZW50Q2VsbCA9IHRoaXMubWFwLmNlbGxBdChlbnRpdHlEZWYuc3RhcnRDZWxsIHx8IHsgeDogMCwgeTogMCB9KTtcbiAgICB0aGlzLmFkZFRvQ2VsbCh0aGlzLmN1cnJlbnRDZWxsKTtcbiAgICB0aGlzLm15TG9jYXRpb24gPSBlbnRpdHlNYXBMb2NhdGlvbkZyb21DZWxsKFxuICAgICAgdGhpcy5jdXJyZW50Q2VsbCxcbiAgICAgIHRoaXMubWFwLFxuICAgICAgdGhpcy5mcmFtZU9mZnNldHNcbiAgICApO1xuICAgIHRoaXMuY2VsbFBhdGggPSBbXTtcbiAgICB0aGlzLmJyYWluID0gYnJhaW47XG4gICAgdGhpcy5kZXN0aW5hdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZhY2luZyA9IGVudGl0eURlZi5mYWNpbmc7XG4gIH1cblxuICBnZXQgaW1hZ2UoKSB7XG4gICAgcmV0dXJuIEFzc2V0cy5nZXQodGhpcy5hc3NldFBhdGhzWzBdKTtcbiAgfVxuXG4gIGdldCBsb2NhdGlvbigpIHtcbiAgICAvLyBjb25zb2xlLmxvZyh0aGlzLm15TG9jYXRpb24pO1xuICAgIHJldHVybiB0aGlzLm15TG9jYXRpb247XG4gIH1cblxuICBzZXQgbG9jYXRpb24obmV3TG9jYXRpb24pIHtcbiAgICBsZXQgbmV3RmFjaW5nID0gdW5kZWZpbmVkO1xuICAgIGlmIChuZXdMb2NhdGlvbiAhPSB1bmRlZmluZWQgJiYgdGhpcy5teUxvY2F0aW9uICE9IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKFxuICAgICAgICBuZXdMb2NhdGlvbi54ID49IHRoaXMubXlMb2NhdGlvbi54ICYmXG4gICAgICAgIG5ld0xvY2F0aW9uLnkgPj0gdGhpcy5teUxvY2F0aW9uLnlcbiAgICAgICkge1xuICAgICAgICBuZXdGYWNpbmcgPSBGYWNpbmcuU09VVEhFQVNUO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgbmV3TG9jYXRpb24ueCA+PSB0aGlzLm15TG9jYXRpb24ueCAmJlxuICAgICAgICBuZXdMb2NhdGlvbi55IDw9IHRoaXMubXlMb2NhdGlvbi55XG4gICAgICApIHtcbiAgICAgICAgbmV3RmFjaW5nID0gRmFjaW5nLk5PUlRIRUFTVDtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIG5ld0xvY2F0aW9uLnggPD0gdGhpcy5teUxvY2F0aW9uLnggJiZcbiAgICAgICAgbmV3TG9jYXRpb24ueSA8PSB0aGlzLm15TG9jYXRpb24ueVxuICAgICAgKSB7XG4gICAgICAgIG5ld0ZhY2luZyA9IEZhY2luZy5OT1JUSFdFU1Q7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBuZXdMb2NhdGlvbi54IDw9IHRoaXMubXlMb2NhdGlvbi54ICYmXG4gICAgICAgIG5ld0xvY2F0aW9uLnkgPj0gdGhpcy5teUxvY2F0aW9uLnlcbiAgICAgICkge1xuICAgICAgICBuZXdGYWNpbmcgPSBGYWNpbmcuU09VVEhXRVNUO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3RmFjaW5nID0gRmFjaW5nLk5PUlRIRUFTVDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5mYWNpbmcgPSBuZXdGYWNpbmc7XG4gICAgdGhpcy5teUxvY2F0aW9uID0gbmV3TG9jYXRpb247XG4gIH1cblxuICBnZXQgZnJhbWVYT3JpZ2luKCkge1xuICAgIGlmICh0aGlzLmZhY2luZyAhPSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmZhY2luZyAqIHRoaXMuZnJhbWVTaXplLndpZHRoO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGdldCBmcmFtZVlPcmlnaW4oKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXNwb25kVG9Nb3VzZShldmVudENlbGwsIGJsb2NraW5nQW5pbWF0aW9uQ2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5hY3Rpdml0eSA9PSB1bmRlZmluZWQgJiYgdGhpcy5icmFpbiAhPSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuYWN0aXZpdHkgPSB0aGlzLmJyYWluLmdldEFjdGl2aXR5KFxuICAgICAgICB0aGlzLFxuICAgICAgICBldmVudENlbGwsXG4gICAgICAgIGJsb2NraW5nQW5pbWF0aW9uQ2FsbGJhY2tcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgYWN0aXZpdHlEb25lKCkge1xuICAgIHRoaXMuYWN0aXZpdHkgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBtb3ZlQmV0d2VlbkNlbGxzKGZyb20sIHRvKSB7XG4gICAgdGhpcy5yZW1vdmVGcm9tQ2VsbChmcm9tKTtcbiAgICB0aGlzLmFkZFRvQ2VsbCh0byk7XG4gIH1cblxuICBhZGRUb0NlbGwoY2VsbCkge1xuICAgIGNlbGwuYWRkQ29udGVudHModGhpcyk7XG4gICAgdGhpcy5jdXJyZW50Q2VsbCA9IGNlbGw7XG4gIH1cblxuICByZW1vdmVGcm9tQ2VsbChjZWxsKSB7XG4gICAgY2VsbC5yZW1vdmVDb250ZW50cyh0aGlzKTtcbiAgICBpZiAoY29vcmRzRXF1YWwodGhpcy5jdXJyZW50Q2VsbCwgY2VsbCkpIHtcbiAgICAgIHRoaXMuY3VycmVudENlbGwgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgdGljaygpIHtcbiAgICBpZiAodGhpcy5hY3Rpdml0eSAhPSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuYWN0aXZpdHkoKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8vIENvZGUgZm9yIGJpbmFyeSBoZWFwIGFkYXB0ZWQgZnJvbVxuLy8gaHR0cDovL2Vsb3F1ZW50amF2YXNjcmlwdC5uZXQvMXN0X2VkaXRpb24vYXBwZW5kaXgyLmh0bWxcbi8vIGJ5IE1hcmlqbiBIYXZlcmJla2VcblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgY2xhc3MgQmluYXJ5SGVhcCB7XG4gIGNvbnN0cnVjdG9yKHNjb3JlRnVuY3Rpb24sIGVxdWFsaXR5RnVuY3Rpb24pIHtcbiAgICB0aGlzLnNjb3JlRnVuY3Rpb24gPSBzY29yZUZ1bmN0aW9uO1xuICAgIHRoaXMuZXF1YWxpdHlGdW5jdGlvbiA9IGVxdWFsaXR5RnVuY3Rpb247XG4gICAgdGhpcy5lbGVtZW50cyA9IFtdO1xuICB9XG5cbiAgZmlyc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHNbMF07XG4gIH1cblxuICBwdXNoKG5ld0VsZW1lbnQpIHtcbiAgICAvLyBBZGQgdGhlIG5ldyBlbGVtZW50IHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgIHRoaXMuZWxlbWVudHMucHVzaChuZXdFbGVtZW50KTtcbiAgICAvLyBBbGxvdyBpdCB0byBidWJibGUgdXAuXG4gICAgdGhpcy5idWJibGVVcCh0aGlzLmVsZW1lbnRzLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcG9wKCkge1xuICAgIC8vIFN0b3JlIHRoZSBmaXJzdCBlbGVtZW50IHNvIHdlIGNhbiByZXR1cm4gaXQgbGF0ZXIuXG4gICAgbGV0IGZpcnN0ID0gdGhpcy5lbGVtZW50c1swXTtcbiAgICAvLyBHZXQgdGhlIGVsZW1lbnQgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgbGV0IGxhc3QgPSB0aGlzLmVsZW1lbnRzLnBvcCgpO1xuICAgIC8vIElmIHRoZXJlIGFyZSBhbnkgZWxlbWVudHMgbGVmdCwgcHV0IHRoZSBlbmQgZWxlbWVudCBhdCB0aGVcbiAgICAvLyBzdGFydCwgYW5kIGxldCBpdCBzaW5rIGRvd24uXG4gICAgaWYgKHRoaXMuZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5lbGVtZW50c1swXSA9IGxhc3Q7XG4gICAgICB0aGlzLnNpbmtEb3duKDApO1xuICAgIH1cbiAgICByZXR1cm4gZmlyc3Q7XG4gIH1cblxuICByZW1vdmUodGFyZ2V0RWxlbWVudCkge1xuICAgIGZvciAobGV0IFtpLCBlbGVtZW50XSBvZiB0aGlzLmVsZW1lbnRzLmVudHJpZXMoKSkge1xuICAgICAgaWYgKHRoaXMuZXF1YWxpdHlGdW5jdGlvbih0YXJnZXRFbGVtZW50LCBlbGVtZW50KSkge1xuICAgICAgICBsZXQgbGFzdEVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzLnBvcCgpO1xuICAgICAgICBpZiAoIShpID09IGxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgdGhpcy5lbGVtZW50c1tpXSA9IGxhc3RFbGVtZW50O1xuICAgICAgICAgIHRoaXMuYnViYmxlVXAoaSk7XG4gICAgICAgICAgdGhpcy5zaW5rRG93bihpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuICB9XG5cbiAgaW5jbHVkZXModGFyZ2V0RWxlbWVudCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzLmluZGV4T2YodGFyZ2V0RWxlbWVudCkgIT0gLTE7XG4gIH1cblxuICBidWJibGVVcChpKSB7XG4gICAgLy8gRmV0Y2ggdGhlIGVsZW1lbnQgdGhhdCBoYXMgdG8gYmUgbW92ZWQuXG4gICAgbGV0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW2ldLFxuICAgICAgc2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oZWxlbWVudCk7XG4gICAgLy8gV2hlbiBhdCAwLCBhbiBlbGVtZW50IGNhbm5vdCBnbyB1cCBhbnkgZnVydGhlci5cbiAgICB3aGlsZSAoaSA+IDApIHtcbiAgICAgIC8vIENvbXB1dGUgdGhlIHBhcmVudCBlbGVtZW50J3MgaW5kZXgsIGFuZCBmZXRjaCBpdC5cbiAgICAgIGxldCBwYXJlbnRJID0gTWF0aC5mbG9vcigoaSArIDEpIC8gMikgLSAxLFxuICAgICAgICBwYXJlbnQgPSB0aGlzLmVsZW1lbnRzW3BhcmVudEldO1xuICAgICAgLy8gSWYgdGhlIHBhcmVudCBoYXMgYSBsZXNzZXIgc2NvcmUsIHRoaW5ncyBhcmUgaW4gb3JkZXIgYW5kIHdlXG4gICAgICAvLyBhcmUgZG9uZS5cbiAgICAgIGlmIChzY29yZSA+PSB0aGlzLnNjb3JlRnVuY3Rpb24ocGFyZW50KSkgYnJlYWs7XG4gICAgICAvLyBPdGhlcndpc2UsIHN3YXAgdGhlIHBhcmVudCB3aXRoIHRoZSBjdXJyZW50IGVsZW1lbnQgYW5kXG4gICAgICAvLyBjb250aW51ZS5cbiAgICAgIHRoaXMuZWxlbWVudHNbcGFyZW50SV0gPSBlbGVtZW50O1xuICAgICAgdGhpcy5lbGVtZW50c1tpXSA9IHBhcmVudDtcbiAgICAgIGkgPSBwYXJlbnRJO1xuICAgIH1cbiAgfVxuXG4gIHNpbmtEb3duKGkpIHtcbiAgICAvLyBMb29rIHVwIHRoZSB0YXJnZXQgZWxlbWVudCBhbmQgaXRzIHNjb3JlLlxuICAgIHZhciBsZW5ndGggPSB0aGlzLmVsZW1lbnRzLmxlbmd0aCxcbiAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW2ldLFxuICAgICAgc2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oZWxlbWVudCk7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gQ29tcHV0ZSB0aGUgaW5kaWNlcyBvZiB0aGUgY2hpbGQgZWxlbWVudHMuXG4gICAgICB2YXIgY2hpbGQyaSA9IChpICsgMSkgKiAyLFxuICAgICAgICBjaGlsZDFpID0gY2hpbGQyaSAtIDE7XG4gICAgICAvLyBUaGlzIGlzIHVzZWQgdG8gc3RvcmUgdGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCxcbiAgICAgIC8vIGlmIGFueS5cbiAgICAgIHZhciBzd2FwID0gbnVsbDtcbiAgICAgIC8vIElmIHRoZSBmaXJzdCBjaGlsZCBleGlzdHMgKGlzIGluc2lkZSB0aGUgYXJyYXkpLi4uXG4gICAgICBpZiAoY2hpbGQxaSA8IGxlbmd0aCkge1xuICAgICAgICAvLyBMb29rIGl0IHVwIGFuZCBjb21wdXRlIGl0cyBzY29yZS5cbiAgICAgICAgdmFyIGNoaWxkMSA9IHRoaXMuZWxlbWVudHNbY2hpbGQxaV0sXG4gICAgICAgICAgY2hpbGQxU2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oY2hpbGQxKTtcbiAgICAgICAgLy8gSWYgdGhlIHNjb3JlIGlzIGxlc3MgdGhhbiBvdXIgZWxlbWVudCdzLCB3ZSBuZWVkIHRvIHN3YXAuXG4gICAgICAgIGlmIChjaGlsZDFTY29yZSA8IHNjb3JlKSBzd2FwID0gY2hpbGQxaTtcbiAgICAgIH1cbiAgICAgIC8vIERvIHRoZSBzYW1lIGNoZWNrcyBmb3IgdGhlIG90aGVyIGNoaWxkLlxuICAgICAgaWYgKGNoaWxkMmkgPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoaWxkMiA9IHRoaXMuZWxlbWVudHNbY2hpbGQyaV0sXG4gICAgICAgICAgY2hpbGQyU2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oY2hpbGQyKTtcbiAgICAgICAgaWYgKGNoaWxkMlNjb3JlIDwgKHN3YXAgPT0gbnVsbCA/IHNjb3JlIDogY2hpbGQxU2NvcmUpKSBzd2FwID0gY2hpbGQyaTtcbiAgICAgIH1cblxuICAgICAgLy8gTm8gbmVlZCB0byBzd2FwIGZ1cnRoZXIsIHdlIGFyZSBkb25lLlxuICAgICAgaWYgKHN3YXAgPT0gbnVsbCkgYnJlYWs7XG5cbiAgICAgIC8vIE90aGVyd2lzZSwgc3dhcCBhbmQgY29udGludWUuXG4gICAgICB0aGlzLmVsZW1lbnRzW2ldID0gdGhpcy5lbGVtZW50c1tzd2FwXTtcbiAgICAgIHRoaXMuZWxlbWVudHNbc3dhcF0gPSBlbGVtZW50O1xuICAgICAgaSA9IHN3YXA7XG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7XG4gIGVudGl0eU1hcExvY2F0aW9uRnJvbUNlbGwsXG4gIGNvb3Jkc0VxdWFsLFxuICBhcnJheUluY2x1ZGVzQ29vcmRzXG59IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBCaW5hcnlIZWFwIH0gZnJvbSAnLi9iaW5hcnlfaGVhcCc7XG5cbmV4cG9ydCBjbGFzcyBNb2JpbGVCcmFpbiB7XG4gIGdldEFjdGl2aXR5KGVudGl0eSwgZXZlbnRDZWxsLCBibG9ja2luZ0FuaW1hdGlvbkNhbGxiYWNrKSB7XG4gICAgbGV0IHN0YXJ0ID0gZW50aXR5LmN1cnJlbnRDZWxsO1xuICAgIGxldCBlbmQgPSBldmVudENlbGw7XG4gICAgbGV0IHBhdGggPSBidWlsZFBhdGhBU3RhcihzdGFydCwgZW5kKTtcbiAgICBsZXQgZGVzdGluYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgYmxvY2tpbmdBbmltYXRpb25DYWxsYmFjayh0cnVlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGRlc3RpbmF0aW9uICE9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgbmV4dFBvc2l0aW9uID0gZ2V0TmV4dE1hcFBvc2l0aW9uKGVudGl0eSwgZGVzdGluYXRpb24pO1xuICAgICAgICBlbnRpdHkubG9jYXRpb24gPSBuZXh0UG9zaXRpb247XG4gICAgICAgIGlmIChjb29yZHNFcXVhbChlbnRpdHkubG9jYXRpb24sIGRlc3RpbmF0aW9uKSkge1xuICAgICAgICAgIGRlc3RpbmF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICBlbnRpdHkubW92ZUJldHdlZW5DZWxscyhlbnRpdHkuY3VycmVudENlbGwsIHBhdGhbMF0pO1xuICAgICAgICBkZXN0aW5hdGlvbiA9IGdldERlc3RpbmF0aW9uKGVudGl0eSwgcGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnRpdHkuYWN0aXZpdHlEb25lKCk7XG4gICAgICAgIGJsb2NraW5nQW5pbWF0aW9uQ2FsbGJhY2soZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TmV4dE1hcFBvc2l0aW9uKGVudGl0eSwgZGVzdGluYXRpb24pIHtcbiAgbGV0IGN1cnJlbnRMb2MgPSB7IHg6IGVudGl0eS5sb2NhdGlvbi54LCB5OiBlbnRpdHkubG9jYXRpb24ueSB9O1xuICBsZXQgZHggPSBjdXJyZW50TG9jLnggLSBkZXN0aW5hdGlvbi54LFxuICAgIGR5ID0gY3VycmVudExvYy55IC0gZGVzdGluYXRpb24ueTtcbiAgbGV0IGRpc3QgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICBsZXQgdmVsWCA9IChkeCAvIGRpc3QpICogNTtcbiAgbGV0IHZlbFkgPSAoZHkgLyBkaXN0KSAqIDU7XG4gIGlmIChNYXRoLmFicyhkeCkgPCBNYXRoLmFicyh2ZWxYKSkge1xuICAgIHZlbFggPSBkeDtcbiAgfVxuICBpZiAoTWF0aC5hYnMoZHkpIDwgTWF0aC5hYnModmVsWSkpIHtcbiAgICB2ZWxZID0gZHk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiAoY3VycmVudExvYy54IC09IHZlbFgpLFxuICAgIHk6IChjdXJyZW50TG9jLnkgLT0gdmVsWSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVzdGluYXRpb24oZW50aXR5LCBjZWxsUGF0aCkge1xuICBsZXQgbmV4dENlbGxEZXN0aW5hdGlvbiA9IGNlbGxQYXRoLnNoaWZ0KCk7XG4gIGxldCBuZXh0RGVzdGluYXRpb24gPSB1bmRlZmluZWQ7XG4gIGlmIChuZXh0Q2VsbERlc3RpbmF0aW9uICE9IHVuZGVmaW5lZCkge1xuICAgIG5leHREZXN0aW5hdGlvbiA9IGVudGl0eU1hcExvY2F0aW9uRnJvbUNlbGwoXG4gICAgICBuZXh0Q2VsbERlc3RpbmF0aW9uLFxuICAgICAgZW50aXR5Lm1hcCxcbiAgICAgIGVudGl0eS5mcmFtZU9mZnNldHNcbiAgICApO1xuICB9XG4gIHJldHVybiBuZXh0RGVzdGluYXRpb247XG59XG5cbi8vIFVzZXMgQnJlbnNlbmhhbSdzIGxpbmUgYWxnb3JpdGhtXG5mdW5jdGlvbiBidWlsZFBhdGgoc3RhcnQsIGVuZCkge1xuICBsZXQgcGF0aCA9IFtdO1xuXG4gIGxldCBjdXJyZW50WCA9IHN0YXJ0LngsXG4gICAgY3VycmVudFkgPSBzdGFydC55O1xuICBsZXQgZGVsdGFYID0gTWF0aC5hYnMoZW5kLnggLSBzdGFydC54KSxcbiAgICBkZWx0YVkgPSBNYXRoLmFicyhlbmQueSAtIHN0YXJ0LnkpO1xuICBsZXQgc2xvcGVYID0gc3RhcnQueCA8IGVuZC54ID8gMSA6IC0xLFxuICAgIHNsb3BlWSA9IHN0YXJ0LnkgPCBlbmQueSA/IDEgOiAtMTtcbiAgbGV0IGVyciA9IGRlbHRhWCAtIGRlbHRhWTtcblxuICB3aGlsZSAoY3VycmVudFggIT0gZW5kLnggfHwgY3VycmVudFkgIT0gZW5kLnkpIHtcbiAgICBsZXQgZXJyMiA9IDIgKiBlcnI7XG4gICAgaWYgKGVycjIgPiBkZWx0YVkgKiAtMSkge1xuICAgICAgZXJyIC09IGRlbHRhWTtcbiAgICAgIGN1cnJlbnRYICs9IHNsb3BlWDtcbiAgICB9IGVsc2UgaWYgKGVycjIgPCBkZWx0YVgpIHtcbiAgICAgIGVyciArPSBkZWx0YVg7XG4gICAgICBjdXJyZW50WSArPSBzbG9wZVk7XG4gICAgfVxuICAgIHBhdGgucHVzaCh7IHg6IGN1cnJlbnRYLCB5OiBjdXJyZW50WSB9KTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cblxuZnVuY3Rpb24gYnVpbGRQYXRoQVN0YXIoc3RhcnQsIGVuZCkge1xuICBsZXQgb3BlbiA9IG5ldyBCaW5hcnlIZWFwKFxuICAgIGEgPT4ge1xuICAgICAgcmV0dXJuIGEuZjtcbiAgICB9LFxuICAgIChhLCBiKSA9PiB7XG4gICAgICByZXR1cm4gY29vcmRzRXF1YWwoYSwgYik7XG4gICAgfVxuICApO1xuICBvcGVuLnB1c2gobmV3IEdyYXBoTm9kZShzdGFydCkpO1xuICBsZXQgY2xvc2VkID0gW107XG4gIHdoaWxlIChvcGVuLnNpemUoKSA+IDApIHtcbiAgICBsZXQgY3VycmVudE5vZGUgPSBvcGVuLnBvcCgpO1xuICAgIGNsb3NlZC5wdXNoKGN1cnJlbnROb2RlKTtcbiAgICBpZiAoY29vcmRzRXF1YWwoY3VycmVudE5vZGUsIGVuZCkpIHtcbiAgICAgIHJldHVybiBidWlsZFBhdGgoY3VycmVudE5vZGUpO1xuICAgIH1cbiAgICBsZXQgbmVpZ2hib3JzID0gY3VycmVudE5vZGUubmVpZ2hib3JzO1xuICAgIGZvciAobGV0IG5laWdoYm9yIG9mIG5laWdoYm9ycykge1xuICAgICAgaWYgKG5laWdoYm9yLnBhdGhhYmxlKCkpIHtcbiAgICAgICAgbGV0IGcgPSBjdXJyZW50Tm9kZS5nICsgMTtcbiAgICAgICAgbGV0IGYgPSBnICsgbWFuaGF0dGVuRGlzdGFuY2UobmVpZ2hib3IsIGVuZCk7XG4gICAgICAgIGlmICghYXJyYXlJbmNsdWRlc0Nvb3JkcyhjbG9zZWQsIG5laWdoYm9yKSkge1xuICAgICAgICAgIGlmICghb3Blbi5pbmNsdWRlcyhuZWlnaGJvcikpIHtcbiAgICAgICAgICAgIG5laWdoYm9yLnBhcmVudCA9IGN1cnJlbnROb2RlO1xuICAgICAgICAgICAgbmVpZ2hib3IuZiA9IGY7XG4gICAgICAgICAgICBvcGVuLnB1c2gobmVpZ2hib3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChuZWlnaGJvci5nID49IGcpIHtcbiAgICAgICAgICBjbG9zZWQgPSBjbG9zZWQuZmlsdGVyKGVsID0+ICFjb29yZHNFcXVhbChlbCwgbmVpZ2hib3IpKTtcbiAgICAgICAgICBuZWlnaGJvci5wYXJlbnQgPSBjdXJyZW50Tm9kZTtcbiAgICAgICAgICBuZWlnaGJvci5mID0gZjtcbiAgICAgICAgICBvcGVuLnB1c2gobmllZ2hib3IpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFhcnJheUluY2x1ZGVzQ29vcmRzKGNsb3NlZCwgbmVpZ2hib3IpKSB7XG4gICAgICAgIGNsb3NlZC5wdXNoKG5laWdoYm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtdOyAvLyBubyBwYXRoIGZvdW5kXG59XG5cbmZ1bmN0aW9uIGJ1aWxkUGF0aChlbmROb2RlKSB7XG4gIGxldCBwYXRoID0gW107XG4gIHdoaWxlIChlbmROb2RlLnBhcmVudCkge1xuICAgIHBhdGgucHVzaChlbmROb2RlLmNlbGwpO1xuICAgIGVuZE5vZGUgPSBlbmROb2RlLnBhcmVudDtcbiAgfVxuICByZXR1cm4gcGF0aC5yZXZlcnNlKCk7XG59XG5cbmZ1bmN0aW9uIG1hbmhhdHRlbkRpc3RhbmNlKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIE1hdGguYWJzKHN0YXJ0LnggLSBlbmQueCkgKyBNYXRoLmFicyhzdGFydC55IC0gZW5kLnkpO1xufVxuXG5jbGFzcyBHcmFwaE5vZGUge1xuICBjb25zdHJ1Y3RvcihjZWxsKSB7XG4gICAgdGhpcy5jZWxsID0gY2VsbDtcbiAgICB0aGlzLmYgPSAwO1xuICB9XG4gIGdldCBuZWlnaGJvcnMoKSB7XG4gICAgaWYgKHRoaXMubXlOZWlnaGJvcnMgPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5jZWxsLm5laWdoYm9ycy5tYXAobmVpZ2hib3IgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IEdyYXBoTm9kZShuZWlnaGJvcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubXlOZWlnaGJvcnM7XG4gIH1cbiAgc2V0IGcobmV3Rykge1xuICAgIC8qIG5vIG9wLCBnIGlzIGNvbXB1dGVkIGZyb20gcGFyZW50LmcgKi9cbiAgfVxuICBnZXQgZygpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQgIT0gdW5kZWZpbmVkID8gdGhpcy5wYXJlbnQuZyArIDEgOiAwO1xuICB9XG4gIGdldCBjb29yZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2VsbC5jb29yZHM7XG4gIH1cbiAgZ2V0IHgoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2VsbC5jb29yZHMueDtcbiAgfVxuICBnZXQgeSgpIHtcbiAgICByZXR1cm4gdGhpcy5jZWxsLmNvb3Jkcy55O1xuICB9XG4gIHBhdGhhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmNlbGwucGF0aGFibGUoKTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgVGlsZSBmcm9tICcuL3RpbGUnO1xuaW1wb3J0IE1hcCBmcm9tICcuL21hcCc7XG5pbXBvcnQgRW50aXR5IGZyb20gJy4vZW50aXR5JztcbmltcG9ydCB7IEFzc2V0cyB9IGZyb20gJy4vYXNzZXRfbWFuYWdlcic7XG5pbXBvcnQgeyBJbnB1dCB9IGZyb20gJy4vaW5wdXQnO1xuaW1wb3J0IHsgTW9iaWxlQnJhaW4gfSBmcm9tICcuL2JyYWluJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NlbmUge1xuICBjb25zdHJ1Y3RvcihzY2VuZURlZiwgdmlld3BvcnQsIHZpZXdwb3J0RGltZW5zaW9ucywgbG9hZENvbXBsZXRlQ2FsbGJhY2spIHtcbiAgICBsZXQgdGlsZXMgPSBzY2VuZURlZi5tYXBEZWYudGlsZUltYWdlUGF0aHMubWFwKHRpbGVJbWFnZVBhdGggPT4ge1xuICAgICAgcmV0dXJuIG5ldyBUaWxlKFt0aWxlSW1hZ2VQYXRoXSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm1hcCA9IG5ldyBNYXAodGlsZXMsIHNjZW5lRGVmLm1hcERlZi5tYXBTaXplKTtcblxuICAgIHRoaXMubW9iaWxlcyA9IHNjZW5lRGVmLm1vYmlsZURlZnMubWFwKG1vYmlsZURlZiA9PiB7XG4gICAgICByZXR1cm4gbmV3IEVudGl0eShtb2JpbGVEZWYsIHRoaXMubWFwLCBuZXcgTW9iaWxlQnJhaW4oKSk7XG4gICAgfSk7XG4gICAgdGhpcy5hY3RpdmVNb2JpbGUgPSB0aGlzLm1vYmlsZXNbMF07XG4gICAgdGhpcy5wcm9wcyA9IHNjZW5lRGVmLnByb3BEZWZzLm1hcChwcm9wRGVmID0+IHtcbiAgICAgIHJldHVybiBuZXcgRW50aXR5KHByb3BEZWYsIHRoaXMubWFwKTtcbiAgICB9KTtcblxuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICB0aGlzLnZpZXdwb3J0RGltZW5zaW9ucyA9IHZpZXdwb3J0RGltZW5zaW9ucztcblxuICAgIEFzc2V0cy5sb2FkQXNzZXRzKFsuLi50aWxlcywgLi4udGhpcy5tb2JpbGVzLCAuLi50aGlzLnByb3BzXSwgKCkgPT4ge1xuICAgICAgdGhpcy52aWV3cG9ydE9mZnNldERpbWVuc2lvbnMgPSB7XG4gICAgICAgIHg6IHRoaXMubWFwLm1hcENhbnZhcy53aWR0aCAvIDIgLSB2aWV3cG9ydERpbWVuc2lvbnMueCAvIDIsXG4gICAgICAgIHk6IHRoaXMubWFwLm1hcENhbnZhcy5oZWlnaHQgLyAyIC0gdmlld3BvcnREaW1lbnNpb25zLnkgLyAyXG4gICAgICB9O1xuICAgICAgbG9hZENvbXBsZXRlQ2FsbGJhY2soKTtcbiAgICB9KTtcblxuICAgIHRoaXMud2FpdGluZ09uQW5pbWF0aW9uID0gZmFsc2U7XG4gIH1cblxuICB0aWNrKCkge1xuICAgIGxldCBtb3VzZUV2ZW50ID0gSW5wdXQuZ2V0TW91c2VFdmVudCgpO1xuICAgIGlmIChtb3VzZUV2ZW50ICE9IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IGV2ZW50Vmlld3BvcnRQb3NpdGlvbiA9IGdldEV2ZW50Vmlld3BvcnRQb3NpdGlvbihcbiAgICAgICAgdGhpcy52aWV3cG9ydCxcbiAgICAgICAgbW91c2VFdmVudFxuICAgICAgKTtcbiAgICAgIGxldCBldmVudE1hcFBvc2l0aW9uID0gZ2V0Q3Vyc29yTWFwUG9zaXRpb24oXG4gICAgICAgIHRoaXMudmlld3BvcnRPZmZzZXREaW1lbnNpb25zLFxuICAgICAgICBldmVudFZpZXdwb3J0UG9zaXRpb25cbiAgICAgICk7XG4gICAgICBsZXQgY2VsbFBvc2l0aW9uID0gZ2V0Q3Vyc29yQ2VsbFBvc2l0aW9uKHRoaXMubWFwLCBldmVudE1hcFBvc2l0aW9uKTtcblxuICAgICAgaWYgKCF0aGlzLndhaXRpbmdPbkFuaW1hdGlvbikge1xuICAgICAgICB0aGlzLmFjdGl2ZU1vYmlsZS5yZXNwb25kVG9Nb3VzZShcbiAgICAgICAgICB0aGlzLm1hcC5jZWxsQXQoY2VsbFBvc2l0aW9uKSxcbiAgICAgICAgICBzaG91bGRXYWl0ID0+IHtcbiAgICAgICAgICAgIHRoaXMud2FpdGluZ09uQW5pbWF0aW9uID0gc2hvdWxkV2FpdDtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHRoaXMubW9iaWxlcy5zbGljZSgtMSlbMF0gPT0gdGhpcy5hY3RpdmVNb2JpbGUpIHtcbiAgICAgICAgICB0aGlzLmFjdGl2ZU1vYmlsZSA9IHRoaXMubW9iaWxlc1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFjdGl2ZU1vYmlsZSA9IHRoaXMubW9iaWxlc1tcbiAgICAgICAgICAgIHRoaXMubW9iaWxlcy5pbmRleE9mKHRoaXMuYWN0aXZlTW9iaWxlKSArIDFcbiAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5tb2JpbGVzLmZvckVhY2gobW9iaWxlID0+IHtcbiAgICAgIG1vYmlsZS50aWNrKCk7XG4gICAgfSk7XG4gICAgdGhpcy5wcm9wcy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgcHJvcC50aWNrKCk7XG4gICAgfSk7XG5cbiAgICBsZXQgY29udGV4dCA9IHRoaXMudmlld3BvcnQuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjb250ZXh0LmNsZWFyUmVjdChcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgdGhpcy52aWV3cG9ydERpbWVuc2lvbnMueCxcbiAgICAgIHRoaXMudmlld3BvcnREaW1lbnNpb25zLnlcbiAgICApO1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgdGhpcy5tYXAubWFwQ2FudmFzLFxuICAgICAgdGhpcy52aWV3cG9ydE9mZnNldERpbWVuc2lvbnMueCxcbiAgICAgIHRoaXMudmlld3BvcnRPZmZzZXREaW1lbnNpb25zLnksXG4gICAgICB0aGlzLnZpZXdwb3J0RGltZW5zaW9ucy54LFxuICAgICAgdGhpcy52aWV3cG9ydERpbWVuc2lvbnMueSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgdGhpcy52aWV3cG9ydERpbWVuc2lvbnMueCxcbiAgICAgIHRoaXMudmlld3BvcnREaW1lbnNpb25zLnlcbiAgICApO1xuXG4gICAgdGhpcy5tb2JpbGVzLmZvckVhY2gobW9iaWxlID0+IHtcbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICBtb2JpbGUuaW1hZ2UsXG4gICAgICAgIG1vYmlsZS5mcmFtZVhPcmlnaW4sXG4gICAgICAgIG1vYmlsZS5mcmFtZVlPcmlnaW4sXG4gICAgICAgIG1vYmlsZS5mcmFtZVNpemUud2lkdGgsXG4gICAgICAgIG1vYmlsZS5mcmFtZVNpemUuaGVpZ2h0LFxuICAgICAgICBtb2JpbGUubG9jYXRpb24ueCAtIHRoaXMudmlld3BvcnRPZmZzZXREaW1lbnNpb25zLngsXG4gICAgICAgIG1vYmlsZS5sb2NhdGlvbi55IC0gdGhpcy52aWV3cG9ydE9mZnNldERpbWVuc2lvbnMueSxcbiAgICAgICAgbW9iaWxlLmZyYW1lU2l6ZS53aWR0aCxcbiAgICAgICAgbW9iaWxlLmZyYW1lU2l6ZS5oZWlnaHRcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnByb3BzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICBjb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgcHJvcC5pbWFnZSxcbiAgICAgICAgcHJvcC5mcmFtZVhPcmlnaW4sXG4gICAgICAgIHByb3AuZnJhbWVZT3JpZ2luLFxuICAgICAgICBwcm9wLmZyYW1lU2l6ZS53aWR0aCxcbiAgICAgICAgcHJvcC5mcmFtZVNpemUuaGVpZ2h0LFxuICAgICAgICBwcm9wLmxvY2F0aW9uLnggLSB0aGlzLnZpZXdwb3J0T2Zmc2V0RGltZW5zaW9ucy54LFxuICAgICAgICBwcm9wLmxvY2F0aW9uLnkgLSB0aGlzLnZpZXdwb3J0T2Zmc2V0RGltZW5zaW9ucy55LFxuICAgICAgICBwcm9wLmZyYW1lU2l6ZS53aWR0aCxcbiAgICAgICAgcHJvcC5mcmFtZVNpemUuaGVpZ2h0XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgSW5wdXQucmVzZXRJbnB1dHMoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJzb3JNYXBQb3NpdGlvbih2aWV3T2Zmc2V0cywgcG9zaXRpb24pIHtcbiAgcmV0dXJuIHsgeDogdmlld09mZnNldHMueCArIHBvc2l0aW9uLngsIHk6IHZpZXdPZmZzZXRzLnkgKyBwb3NpdGlvbi55IH07XG59XG5cbmZ1bmN0aW9uIGdldEN1cnNvckNlbGxQb3NpdGlvbihtYXAsIHBvc2l0aW9uKSB7XG4gIGxldCBoYWxmVGlsZVdpZHRoID0gbWFwLnRpbGVXaWR0aCAvIDI7XG4gIGxldCBoYWxmVGlsZUhlaWdodCA9IG1hcC50aWxlSGVpZ2h0IC8gMjtcbiAgbGV0IGhhbGZNYXBTaXplID0gbWFwLm1hcFNpemUgLyAyO1xuICBsZXQgY2VsbFggPVxuICAgIChwb3NpdGlvbi54IC8gaGFsZlRpbGVXaWR0aCArIHBvc2l0aW9uLnkgLyBoYWxmVGlsZUhlaWdodCkgLyAyIC1cbiAgICBoYWxmTWFwU2l6ZTtcbiAgbGV0IGNlbGxZID1cbiAgICAocG9zaXRpb24ueSAvIGhhbGZUaWxlSGVpZ2h0IC0gcG9zaXRpb24ueCAvIGhhbGZUaWxlV2lkdGgpIC8gMiArXG4gICAgaGFsZk1hcFNpemU7XG4gIHJldHVybiB7IHg6IE1hdGguZmxvb3IoY2VsbFgpLCB5OiBNYXRoLmZsb29yKGNlbGxZKSB9O1xufVxuXG5mdW5jdGlvbiBnZXRFdmVudFZpZXdwb3J0UG9zaXRpb24odmlld3BvcnQsIGV2ZW50KSB7XG4gIGxldCByZWN0ID0gdmlld3BvcnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGxldCB4ID0gZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgbGV0IHkgPSBldmVudC5jbGllbnRZIC0gcmVjdC50b3A7XG4gIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGNvbnN0IHNjZW5lRGVmID0ge1xuICBtYXBEZWY6IHtcbiAgICBtYXBTaXplOiAxMCxcbiAgICB0aWxlSW1hZ2VQYXRoczogW1xuICAgICAgJy4vc3JjL2ltZy9ncm91bmRfdGlsZXMvYnJpY2twYXZlcnMyLnBuZycsXG4gICAgICAnLi9zcmMvaW1nL2dyb3VuZF90aWxlcy9jb25jcmV0ZTM2OGEucG5nJyxcbiAgICAgICcuL3NyYy9pbWcvZ3JvdW5kX3RpbGVzL2NyZXRlYnJpY2s5NzAucG5nJyxcbiAgICAgICcuL3NyYy9pbWcvZ3JvdW5kX3RpbGVzL2RpcnQucG5nJyxcbiAgICAgICcuL3NyYy9pbWcvZ3JvdW5kX3RpbGVzL2RpcnRzYW5kMi5wbmcnLFxuICAgICAgJy4vc3JjL2ltZy9ncm91bmRfdGlsZXMvcm9jay5wbmcnLFxuICAgICAgJy4vc3JjL2ltZy9ncm91bmRfdGlsZXMvc25vdy5wbmcnLFxuICAgICAgJy4vc3JjL2ltZy9ncm91bmRfdGlsZXMvc3RvbmUucG5nJ1xuICAgIF1cbiAgfSxcbiAgbW9iaWxlRGVmczogW1xuICAgIHtcbiAgICAgIGltYWdlUGF0aHM6IFsnLi9zcmMvaW1nL21vYmlsZXMvOHdheV9tb2JpbGUucG5nJ10sXG4gICAgICBzdGFydENlbGw6IHsgeDogMywgeTogMyB9LFxuICAgICAgZnJhbWVTaXplOiB7IHdpZHRoOiA2MCwgaGVpZ2h0OiAxMTAgfSxcbiAgICAgIGZyYW1lT2Zmc2V0czogeyB4OiAzMCwgeTogMTAwIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGltYWdlUGF0aHM6IFsnLi9zcmMvaW1nL21vYmlsZXMvOHdheV9tb2JpbGUucG5nJ10sXG4gICAgICBzdGFydENlbGw6IHsgeDogNSwgeTogNCB9LFxuICAgICAgZnJhbWVTaXplOiB7IHdpZHRoOiA2MCwgaGVpZ2h0OiAxMTAgfSxcbiAgICAgIGZyYW1lT2Zmc2V0czogeyB4OiAzMCwgeTogMTAwIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGltYWdlUGF0aHM6IFsnLi9zcmMvaW1nL21vYmlsZXMvOHdheV9tb2JpbGUucG5nJ10sXG4gICAgICBzdGFydENlbGw6IHsgeDogMywgeTogNiB9LFxuICAgICAgZnJhbWVTaXplOiB7IHdpZHRoOiA2MCwgaGVpZ2h0OiAxMTAgfSxcbiAgICAgIGZyYW1lT2Zmc2V0czogeyB4OiAzMCwgeTogMTAwIH1cbiAgICB9XG4gIF0sXG4gIHByb3BEZWZzOiBbXG4gICAge1xuICAgICAgaW1hZ2VQYXRoczogWycuL3NyYy9pbWcvcHJvcHMvc3RhdHVlMS0wMS5wbmcnXSxcbiAgICAgIHN0YXJ0Q2VsbDogeyB4OiA1LCB5OiA1IH0sXG4gICAgICBmcmFtZVNpemU6IHsgd2lkdGg6IDEyOCwgaGVpZ2h0OiAxMjggfSxcbiAgICAgIGZyYW1lT2Zmc2V0czogeyB4OiA2NCwgeTogMTEyIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGltYWdlUGF0aHM6IFsnLi9zcmMvaW1nL3Byb3BzL3N0YXR1ZTEtMDIucG5nJ10sXG4gICAgICBzdGFydENlbGw6IHsgeDogMCwgeTogMyB9LFxuICAgICAgZnJhbWVTaXplOiB7IHdpZHRoOiAxMjgsIGhlaWdodDogMTI4IH0sXG4gICAgICBmcmFtZU9mZnNldHM6IHsgeDogNjQsIHk6IDExMiB9XG4gICAgfSxcbiAgICB7XG4gICAgICBpbWFnZVBhdGhzOiBbJy4vc3JjL2ltZy9wcm9wcy9zdGF0dWUxLTAzLnBuZyddLFxuICAgICAgc3RhcnRDZWxsOiB7IHg6IDQsIHk6IDEgfSxcbiAgICAgIGZyYW1lU2l6ZTogeyB3aWR0aDogMTI4LCBoZWlnaHQ6IDEyOCB9LFxuICAgICAgZnJhbWVPZmZzZXRzOiB7IHg6IDY0LCB5OiAxMTIgfVxuICAgIH0sXG4gICAge1xuICAgICAgaW1hZ2VQYXRoczogWycuL3NyYy9pbWcvcHJvcHMvc3RhdHVlMS0wNC5wbmcnXSxcbiAgICAgIHN0YXJ0Q2VsbDogeyB4OiA1LCB5OiAxIH0sXG4gICAgICBmcmFtZVNpemU6IHsgd2lkdGg6IDEyOCwgaGVpZ2h0OiAxMjggfSxcbiAgICAgIGZyYW1lT2Zmc2V0czogeyB4OiA2NCwgeTogMTEyIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGltYWdlUGF0aHM6IFsnLi9zcmMvaW1nL3Byb3BzL3N0YXR1ZTEtMDIucG5nJ10sXG4gICAgICBzdGFydENlbGw6IHsgeDogNiwgeTogMCB9LFxuICAgICAgZnJhbWVTaXplOiB7IHdpZHRoOiAxMjgsIGhlaWdodDogMTI4IH0sXG4gICAgICBmcmFtZU9mZnNldHM6IHsgeDogNjQsIHk6IDExMiB9XG4gICAgfSxcbiAgICB7XG4gICAgICBpbWFnZVBhdGhzOiBbJy4vc3JjL2ltZy9wcm9wcy9zdGF0dWUxLTAzLnBuZyddLFxuICAgICAgc3RhcnRDZWxsOiB7IHg6IDcsIHk6IDkgfSxcbiAgICAgIGZyYW1lU2l6ZTogeyB3aWR0aDogMTI4LCBoZWlnaHQ6IDEyOCB9LFxuICAgICAgZnJhbWVPZmZzZXRzOiB7IHg6IDY0LCB5OiAxMTIgfVxuICAgIH1cbiAgXVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0ICcuL3N0eWxlcy9pbmRleC5jc3MnO1xuXG5pbXBvcnQgeyBJbnB1dCB9IGZyb20gJy4vaW5wdXQnO1xuaW1wb3J0IFNjZW5lIGZyb20gJy4vc2NlbmUnO1xuaW1wb3J0IHsgc2NlbmVEZWYgfSBmcm9tICcuL3NjZW5lX2RlZmluaXRpb24nO1xuaW1wb3J0IHsgQmluYXJ5SGVhcCB9IGZyb20gJy4vYmluYXJ5X2hlYXAnO1xuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCdQcm94bWEgUmV2ZXJpZSBhcHByb2FjaGVzIScpO1xuXG4gIC8vIGNvbnNvbGUubG9nKCd0ZXN0aW5nIEJpbmFyeUhlYXAnKTtcbiAgLy8gbGV0IGhlYXAgPSBuZXcgQmluYXJ5SGVhcChcbiAgLy8gICBlbCA9PiB7XG4gIC8vICAgICByZXR1cm4gZWw7XG4gIC8vICAgfSxcbiAgLy8gICAoYSwgYikgPT4ge1xuICAvLyAgICAgcmV0dXJuIGEgPT0gYjtcbiAgLy8gICB9XG4gIC8vICk7XG4gIC8vIGZvciAobGV0IGVudHJ5IG9mIFsxMCwgMywgNCwgOCwgMiwgOSwgNywgMSwgMiwgNiwgNV0pIHtcbiAgLy8gICBoZWFwLnB1c2goZW50cnkpO1xuICAvLyB9XG4gIC8vIGhlYXAucmVtb3ZlKDIpO1xuICAvLyB3aGlsZSAoaGVhcC5zaXplKCkgPiAwKSB7XG4gIC8vICAgY29uc29sZS5sb2coaGVhcC5wb3AoKSk7XG4gIC8vIH1cblxuICBsZXQgdGlja0xlbmd0aCA9IDUwO1xuXG4gIHZhciB2aWV3cG9ydCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd2aWV3cG9ydC1jYW52YXMnKTtcbiAgbGV0IHZpZXdwb3J0RGltZW5zaW9ucyA9IHsgeDogNjAwLCB5OiA0MDAgfTtcbiAgdmlld3BvcnQud2lkdGggPSB2aWV3cG9ydERpbWVuc2lvbnMueDtcbiAgdmlld3BvcnQuaGVpZ2h0ID0gdmlld3BvcnREaW1lbnNpb25zLnk7XG5cbiAgbGV0IHNjZW5lID0gbmV3IFNjZW5lKHNjZW5lRGVmLCB2aWV3cG9ydCwgdmlld3BvcnREaW1lbnNpb25zLCAoKSA9PiB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aWNrKCk7XG4gICAgfSwgMCk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgc2NlbmUudGljaygpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGljaygpO1xuICAgIH0sIHRpY2tMZW5ndGgpO1xuICB9XG5cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGV2ZW50ID0+IHtcbiAgICBJbnB1dC5rZXlEb3duKGV2ZW50LmtleSk7XG4gIH0pO1xuXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZXZlbnQgPT4ge1xuICAgIElucHV0LmtleVVwKGV2ZW50LmtleSk7XG4gIH0pO1xuXG4gIHZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBldmVudCA9PiB7XG4gICAgSW5wdXQubW91c2VVcChldmVudCk7XG4gIH0pO1xufSk7XG4iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")},,function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zdHlsZXMvaW5kZXguY3NzPzU5ZDAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n")}]);